// Copyright (c) Microsoft Corporation. All rights reserved.
// Licensed under the MIT License.

#ifndef airsim_core_FastPhysicsEngine_hpp
#define airsim_core_FastPhysicsEngine_hpp

#include "common/FirstOrderFilter.hpp"
#include <numeric>

#include "common/Common.hpp"
#include "physics/PhysicsEngineBase.hpp"
#include <iostream>
#include <sstream>
#include <fstream>
#include <memory>
#include "common/CommonStructs.hpp"
#include "common/SteppableClock.hpp"
#include <cinttypes>
#include <vector>
#include <cfloat>
#include <math.h>

namespace msr {
    namespace airlib {

        class FastPhysicsEngine : public PhysicsEngineBase {
        public:
            FastPhysicsEngine(bool enable_ground_lock = true, Vector3r wind = Vector3r::Zero())
                : enable_ground_lock_(enable_ground_lock), wind_(wind)
            {
            }

            //*** Start: UpdatableState implementation ***//
            virtual void resetImplementation() override
            {
                for (PhysicsBody* body_ptr : *this) {
                    initPhysicsBody(body_ptr);
                }
            }

            virtual void insert(PhysicsBody* body_ptr) override
            {
                PhysicsEngineBase::insert(body_ptr);

                initPhysicsBody(body_ptr);
            }

            virtual void update() override
            {
                PhysicsEngineBase::update();

                for (PhysicsBody* body_ptr : *this) {
                    updatePhysics(*body_ptr);
                }
            }
            virtual void reportState(StateReporter& reporter) override
            {
                for (PhysicsBody* body_ptr : *this) {
                    reporter.writeValue("Phys", debug_string_.str());
                    reporter.writeValue("Is Grounded", body_ptr->isGrounded());
                    reporter.writeValue("Force (world)", body_ptr->getWrench().force);
                    reporter.writeValue("Torque (body)", body_ptr->getWrench().torque);
                }
                //call base
                UpdatableObject::reportState(reporter);
            }
            //*** End: UpdatableState implementation ***//

            // Set Wind, for API and Settings implementation
            void setWind(const Vector3r& wind) override
            {
                wind_ = wind;
            }

        private:
            void initPhysicsBody(PhysicsBody* body_ptr)
            {
                body_ptr->last_kinematics_time = clock()->nowNanos();
            }

            void updatePhysics(PhysicsBody& body)
            {
                TTimeDelta dt = clock()->updateSince(body.last_kinematics_time);

                body.lock();
                if (initial_time == -1)
                {
                    previous = body.getKinematics();
                }
                initial_time = 1;
                //get current kinematics state of the body - this state existed since last dt seconds
                const Kinematics::State& current = body.getKinematics();
                Kinematics::State next;
                Wrench next_wrench;

                //first compute the response as if there was no collision
                //this is necessary to take in to account forces and torques generated by body
                bool bebop2_kin = true;

                if (bebop2_kin)
                {
                    getNextKinematicsNoCollisionBB2(dt, body, current, next, next_wrench, wind_, propeller_damage_coefficients);
                }
                else
                {
                    getNextKinematicsNoCollision(dt, body, current, next, next_wrench, wind_, propeller_damage_coefficients);
                }

                //if there is collision, see if we need collision response
                const CollisionInfo collision_info = body.getCollisionInfo();
                CollisionResponse& collision_response = body.getCollisionResponseInfo();
                //if collision was already responded then do not respond to it until we get updated information
                if (body.isGrounded() || (collision_info.has_collided && collision_response.collision_time_stamp != collision_info.time_stamp)) {
                    bool is_collision_response = getNextKinematicsOnCollision(dt, collision_info, body,
                        current, next, next_wrench, enable_ground_lock_);
                    updateCollisionResponseInfo(collision_info, next, is_collision_response, collision_response);
                    //throttledLogOutput("*** has collision", 0.1);
                }
                //else throttledLogOutput("*** no collision", 0.1);

                //Utils::log(Utils::stringf("T-VEL %s %" PRIu64 ": ", 
                //    VectorMath::toString(next.twist.linear).c_str(), clock()->getStepCount()));
                previous = current;
                body.setWrench(next_wrench);
                body.updateKinematics(next);
                body.unlock();
                //body.collectCameraData();


                //TODO: this is now being done in PawnSimApi::update. We need to re-think this sequence
                //with below commented out - Arducopter GPS may not work.
                //body.getEnvironment().setPosition(next.pose.position);
                //body.getEnvironment().update();

            }

            static void updateCollisionResponseInfo(const CollisionInfo& collision_info, const Kinematics::State& next,
                bool is_collision_response, CollisionResponse& collision_response)
            {
                collision_response.collision_time_stamp = collision_info.time_stamp;
                ++collision_response.collision_count_raw;

                //increment counter if we didn't collided with high velocity (like resting on ground)
                if (is_collision_response && next.twist.linear.squaredNorm() > kRestingVelocityMax * kRestingVelocityMax)
                    ++collision_response.collision_count_non_resting;

            }

            //return value indicates if collision response was generated
            static bool getNextKinematicsOnCollision(TTimeDelta dt, const CollisionInfo& collision_info, PhysicsBody& body,
                const Kinematics::State& current, Kinematics::State& next, Wrench& next_wrench, bool enable_ground_lock)
            {
                /************************* Collision response ************************/
                const real_T dt_real = static_cast<real_T>(dt);

                //are we going away from collision? if so then keep using computed next state
                if (collision_info.normal.dot(next.twist.linear) >= 0.0f)
                    return false;

                /********** Core collision response ***********/
                //get avg current velocity
                const Vector3r vcur_avg = current.twist.linear + current.accelerations.linear * dt_real;

                //get average angular velocity
                const Vector3r angular_avg = current.twist.angular + current.accelerations.angular * dt_real;

                //contact point vector
                Vector3r r = collision_info.impact_point - collision_info.position;

                //see if impact is straight at body's surface (assuming its box)
                const Vector3r normal_body = VectorMath::transformToBodyFrame(collision_info.normal, current.pose.orientation);
                const bool is_ground_normal = Utils::isApproximatelyEqual(std::abs(normal_body.z()), 1.0f, kAxisTolerance);
                bool ground_collision = false;
                const float z_vel = vcur_avg.z();
                const bool is_landing = z_vel > std::abs(vcur_avg.x()) && z_vel > std::abs(vcur_avg.y());

                real_T restitution = body.getRestitution();
                real_T friction = body.getFriction();

                if (is_ground_normal && is_landing
                    // So normal_body is the collision normal translated into body coords, why does an x==1 or y==1
                    // mean we are coliding with the ground???
                    // || Utils::isApproximatelyEqual(std::abs(normal_body.x()), 1.0f, kAxisTolerance) 
                    // || Utils::isApproximatelyEqual(std::abs(normal_body.y()), 1.0f, kAxisTolerance) 
                    ) {
                    // looks like we are coliding with the ground.  We don't want the ground to be so bouncy
                    // so we reduce the coefficient of restitution.  0 means no bounce.
                    // TODO: it would be better if we did this based on the material we are landing on.
                    // e.g. grass should be inelastic, but a hard surface like the road should be more bouncy.
                    restitution = 0;
                    // crank up friction with the ground so it doesn't try and slide across the ground
                    // again, this should depend on the type of surface we are landing on.
                    friction = 1;

                    //we have collided with ground straight on, we will fix orientation later
                    ground_collision = is_ground_normal;
                }

                //velocity at contact point
                const Vector3r vcur_avg_body = VectorMath::transformToBodyFrame(vcur_avg, current.pose.orientation);
                const Vector3r contact_vel_body = vcur_avg_body + angular_avg.cross(r);

                /*
                    GafferOnGames - Collision response with columb friction
                    http://gafferongames.com/virtual-go/collision-response-and-coulomb-friction/
                    Assuming collision is with static fixed body,
                    impulse magnitude = j = -(1 + R)V.N / (1/m + (I'(r X N) X r).N)
                    Physics Part 3, Collision Response, Chris Hecker, eq 4(a)
                    http://chrishecker.com/images/e/e7/Gdmphys3.pdf
                    V(t+1) = V(t) + j*N / m
                */
                const real_T impulse_mag_denom = 1.0f / body.getMass() +
                    (body.getInertiaInv() * r.cross(normal_body))
                    .cross(r)
                    .dot(normal_body);
                const real_T impulse_mag = -contact_vel_body.dot(normal_body) * (1 + restitution) / impulse_mag_denom;

                next.twist.linear = vcur_avg + collision_info.normal * (impulse_mag / body.getMass());
                next.twist.angular = angular_avg + r.cross(normal_body) * impulse_mag;

                //above would modify component in direction of normal
                //we will use friction to modify component in direction of tangent
                const Vector3r contact_tang_body = contact_vel_body - normal_body * normal_body.dot(contact_vel_body);
                const Vector3r contact_tang_unit_body = contact_tang_body.normalized();
                const real_T friction_mag_denom = 1.0f / body.getMass() +
                    (body.getInertiaInv() * r.cross(contact_tang_unit_body))
                    .cross(r)
                    .dot(contact_tang_unit_body);
                const real_T friction_mag = -contact_tang_body.norm() * friction / friction_mag_denom;

                const Vector3r contact_tang_unit = VectorMath::transformToWorldFrame(contact_tang_unit_body, current.pose.orientation);
                next.twist.linear += contact_tang_unit * friction_mag;
                next.twist.angular += r.cross(contact_tang_unit_body) * (friction_mag / body.getMass());

                //TODO: implement better rolling friction
                next.twist.angular *= 0.9f;

                // there is no acceleration during collision response, this is a hack, but without it the acceleration cancels
                // the computed impulse response too much and stops the vehicle from bouncing off the collided object.
                next.accelerations.linear = Vector3r::Zero();
                next.accelerations.angular = Vector3r::Zero();

                next.pose = current.pose;
                if (enable_ground_lock && ground_collision) {
                    float pitch, roll, yaw;
                    VectorMath::toEulerianAngle(next.pose.orientation, pitch, roll, yaw);
                    pitch = roll = 0;
                    next.pose.orientation = VectorMath::toQuaternion(pitch, roll, yaw);

                    //there is a lot of random angular velocity when vehicle is on the ground
                    next.twist.angular = Vector3r::Zero();

                    // also eliminate any linear velocity due to twist - since we are sitting on the ground there shouldn't be any.
                    next.twist.linear = Vector3r::Zero();
                    next.pose.position = collision_info.position;
                    body.setGrounded(true);

                    // but we do want to "feel" the ground when we hit it (we should see a small z-acc bump)
                    // equal and opposite our downward velocity.
                    next.accelerations.linear = -0.5f * body.getMass() * vcur_avg;

                    //throttledLogOutput("*** Triggering ground lock", 0.1);
                }
                else
                {
                    //else keep the orientation
                    next.pose.position = collision_info.position + (collision_info.normal * collision_info.penetration_depth) + next.twist.linear * (dt_real * kCollisionResponseCycles);
                }
                next_wrench = Wrench::zero();

                //Utils::log(Utils::stringf("*** C-VEL %s: ", VectorMath::toString(next.twist.linear).c_str()));

                return true;
            }

            void throttledLogOutput(const std::string& msg, double seconds)
            {
                TTimeDelta dt = clock()->elapsedSince(last_message_time);
                const real_T dt_real = static_cast<real_T>(dt);
                if (dt_real > seconds)
                {
                    Utils::log(msg);
                    last_message_time = clock()->nowNanos();
                }
            }

            static Wrench getDragWrench(const PhysicsBody& body, const Quaternionr& orientation,
                const Vector3r& linear_vel, const Vector3r& angular_vel_body, const Vector3r& wind_world)
            {
                //add linear drag due to velocity we had since last dt seconds + wind
                //drag vector magnitude is proportional to v^2, direction opposite of velocity
                //total drag is b*v + c*v*v but we ignore the first term as b << c (pg 44, Classical Mechanics, John Taylor)
                //To find the drag force, we find the magnitude in the body frame and unit vector direction in world frame
                //http://physics.stackexchange.com/questions/304742/angular-drag-on-body
                //similarly calculate angular drag
                //note that angular velocity, acceleration, torque are already in body frame

                Wrench wrench = Wrench::zero();
                const real_T air_density = body.getEnvironment().getState().air_density;

                // Use relative velocity of the body wrt wind
                const Vector3r relative_vel = linear_vel - wind_world;
                const Vector3r linear_vel_body = VectorMath::transformToBodyFrame(relative_vel, orientation);

                for (uint vi = 0; vi < body.dragVertexCount(); ++vi) {
                    const auto& vertex = body.getDragVertex(vi);
                    const Vector3r vel_vertex = linear_vel_body + angular_vel_body.cross(vertex.getPosition());
                    const real_T vel_comp = vertex.getNormal().dot(vel_vertex);
                    //if vel_comp is -ve then we cull the face. If velocity too low then drag is not generated
                    if (vel_comp > kDragMinVelocity) {
                        const Vector3r drag_force = vertex.getNormal() * (-vertex.getDragFactor() * air_density * vel_comp * vel_comp);
                        const Vector3r drag_torque = vertex.getPosition().cross(drag_force);

                        wrench.force += drag_force;
                        wrench.torque += drag_torque;
                    }
                }

                //convert force to world frame, leave torque to local frame
                wrench.force = VectorMath::transformToWorldFrame(wrench.force, orientation);

                return wrench;
            }

            static Wrench getBodyWrench(const PhysicsBody& body, const Quaternionr& orientation, float prop_damage[])
            {
                //set wrench sum to zero
                Wrench wrench = Wrench::zero();
                //calculate total force on rigid body's center of gravity
                for (uint i = 0; i < body.wrenchVertexCount(); ++i) {
                    //aggregate total
                    std::cout << prop_damage[i] << std::endl;
                    const PhysicsBodyVertex& vertex = body.getWrenchVertex(i);
                    const auto& vertex_wrench = vertex.getWrench();
                    const auto damage_coeff = prop_damage[i];
                    Vector3r local_force = Vector3r(vertex_wrench.force.x() * damage_coeff, vertex_wrench.force.y() * damage_coeff, vertex_wrench.force.z() * damage_coeff);
                    Vector3r local_torque = Vector3r(vertex_wrench.torque.x() * damage_coeff, vertex_wrench.torque.y() * damage_coeff, vertex_wrench.torque.z() * damage_coeff);
                    Wrench local_wrench = Wrench::zero();
                    local_wrench.force = local_force;
                    local_wrench.torque = local_torque;
                    wrench += local_wrench;

                    //const auto& vertex_wrench = vertex.getWrench();
                    //wrench += vertex_wrench;

                    //add additional torque due to force applies farther than COG
                    // tau = r X F
                    Wrench wrench_cross = Wrench::zero();
                    wrench_cross.torque = vertex.getPosition().cross(vertex_wrench.force);
                    Vector3r cross_torque = Vector3r(wrench_cross.torque.x() * damage_coeff, wrench_cross.torque.y() * damage_coeff, wrench_cross.torque.z() * damage_coeff);
                    wrench.torque += cross_torque;
                    //wrench.torque += vertex.getPosition().cross(vertex_wrench.force);
                }

                //convert force to world frame, leave torque to local frame
                wrench.force = VectorMath::transformToWorldFrame(wrench.force, orientation);

                return wrench;
            }

            static int findNearestNeighbourIndex(float value, std::vector<float>& x)
            {
                float dist = FLT_MAX;
                int idx = -1;
                for (int i = 0; i < x.size(); ++i) {
                    float newDist = value - x[i];
                    if (newDist > 0 && newDist < dist) {
                        dist = newDist;
                        idx = i;
                    }
                }

                return idx;
            }

            static float interp1(std::vector<float>& x, std::vector<float>& y, float x_new)
            {
                float y_new;

                std::vector<float> dx, dy, slope, intercept;
                dx.reserve(x.size());
                dy.reserve(x.size());
                slope.reserve(x.size());
                intercept.reserve(x.size());
                for (int i = 0; i < x.size(); ++i) {
                    if (i < x.size() - 1)
                    {
                        dx.push_back(x[i + 1] - x[i]);
                        dy.push_back(y[i + 1] - y[i]);
                        slope.push_back(dy[i] / dx[i]);
                        intercept.push_back(y[i] - x[i] * slope[i]);
                    }
                    else
                    {
                        dx.push_back(dx[i - 1]);
                        dy.push_back(dy[i - 1]);
                        slope.push_back(slope[i - 1]);
                        intercept.push_back(intercept[i - 1]);
                    }
                }
                if (x_new <= x[0])
                {
                    y_new = slope[0] * x_new + intercept[0];
                }
                else
                {
                    int idx = findNearestNeighbourIndex(x_new, x);
                    y_new = slope[idx] * x_new + intercept[idx];
                }
                return y_new;
            }

            // Function that creates a 3rd degree polynomial with 3 parameters
            static std::vector<real_T> P33(real_T x1, real_T x2, real_T x3 = 1, real_T U = 1)
            {
                real_T A1 = U;
                real_T A2 = x1 * U;
                real_T A3 = x2 * U;
                real_T A4 = x3 * U;
                real_T A5 = x1*x1 * U;
                real_T A6 = x2*x2 * U;
                real_T A7 = x3*x3 * U;
                real_T A8 = x1*x2 * U;
                real_T A9 = x2*x3 * U;
                real_T A10 = x3*x1 * U;
                real_T A11 = x1*x1*x1 * U;
                real_T A12 = x2*x2*x2 * U;
                real_T A13 = x3*x3*x3 * U;
                real_T A14 = x1*x2*x2 * U;
                real_T A15 = x1*x3*x3 * U;
                real_T A16 = x1*x1*x2 * U;
                real_T A17 = x1*x1*x3 * U;
                real_T A18 = x2*x2*x3 * U;
                real_T A19 = x2*x3*x3 * U;
                real_T A20 = x1*x2*x3 * U;


                std::vector<real_T> P33_output = { A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12, A13, A14, A15, A16, A17, A18, A19, A20 };
                return P33_output;
            }

            // Function to find the 5th degree polynomial with 2 parameters
            static std::vector<real_T> P52(real_T x1, real_T  x2, real_T U = 1)
            {

                real_T A1 = U;
                real_T A2 = x1 * U;
                real_T A3 = x2 * U;
                real_T A4 = x2 * x2 * U;
                real_T A5 = x1 * x2 * U;
                real_T A6 = x2 * x2 * U;
                real_T A7 = x1*x1*x1 * U;
                real_T A8 = x1 *x1* x2 * U;
                real_T A9 = x1 * x2 *x2 * U;
                real_T A10 = x2 * x2 *x2 * U;
                real_T A11 = x1 * x1 * x1 * x1 * U;
                real_T A12 = x1 * x1 * x1 * x2 * U;
                real_T A13 = x1 * x1 * x2 * x2 * U;
                real_T A14 = x1 * x2 * x2 * x2 * U;
                real_T A15 = x2 * x2 * x2 * x2 * U;
                real_T A16 = x1 * x1 * x1 * x1 * x1 * U;
                real_T A17 = x1 * x1 * x1 * x1 * x2 * U;
                real_T A18 = x1 * x1 * x1 * x2 * x2 * U;
                real_T A19 = x1 * x1 * x2 * x2 * x2 * U;
                real_T A20 = x1 * x2 * x2 * x2 * x2 * U;
                real_T A21 = x2 * x2 * x2 * x2 * x2 * U;

                std::vector<real_T> P52_output = { A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12, A13, A14, A15, A16, A17, A18, A19, A20, A21 };
                return P52_output;

            }

            // regressor generator 3rd order polynomial function with 2 inputs
            static std::vector<real_T> P32(real_T x1, real_T x2, real_T U = 1, real_T bias = -1)
            {
                real_T A2 = x1 * U;
                real_T A3 = x2 * U;
                real_T A4 = x1 * x1 * U;
                real_T A5 = x2 * x2 * U;
                real_T A6 = x1 * x2 * U;
                real_T A7 = x1 * x1 * x1 * U;
                real_T A8 = x2 * x2 * x2 * U;
                real_T A9 = x1 * x2 * x2 * U;
                real_T A10 = x1 * x1 * x2 * U;

                std::vector<real_T> P32_output;
                if (bias != -1)
                {
                    real_T A1 = 1.0f;
                    P32_output = { A1, A2, A3, A4, A5, A6, A7, A8, A9, A10 };
                }
                else
                {
                    P32_output = { A2, A3, A4, A5, A6, A7, A8, A9, A10 };
                }
                return P32_output;
            }

            static std::vector<real_T> Fn(real_T x, int n = 1, real_T bias = 1.0f, real_T U = 1.0f, real_T alpha = 0.0f, real_T beta = 0.0f)
            {

                std::vector<real_T> A_F;
                if (bias != 0)
                {
                    A_F.push_back(1.0f);
                }

                for (int i = 0; i < n; i++)
                {
                    real_T sine_component = sin((i+1.0f)*x)*U;
                    std::vector<real_T> Ai1 = P32(alpha, beta, sine_component);

                    real_T cosine_component = cos((i+1.0f)*x)*U;
                    std::vector<real_T> Ai2 = P32(alpha, beta, cosine_component);

                    A_F.insert(A_F.end(), Ai1.begin(), Ai1.end());
                    A_F.insert(A_F.end(), Ai2.begin(), Ai2.end());
                }

                return A_F;
            }

            static real_T calc_beta2(real_T uy, real_T vx)
            {
                if (uy == 0 && vx == 0)
                {
                    return 0.0f;
                }

                real_T beta = atan2(uy, vx);
                if (beta < 0)
                {
                    beta = 2.0f * M_PIf + beta;
                }
                beta = beta - M_PIf / 2;
                if (beta < 0)
                {
                    beta = 2.0f * M_PIf + beta;
                }
                return beta;
            }

            real_T matlabFmod(real_T numerator, real_T denominator)
            {
                real_T result = fmod(numerator, denominator);
                return result >= 0 ? result : result + denominator;
            }

            real_T gaussian_noise(real_T clean_number, real_T mean, real_T variance)
            {
                real_T standard_deviation = sqrt(variance);
                std::normal_distribution<double> distribution(mean, standard_deviation);
                real_T dirty_number = clean_number + distribution(generator);
                return dirty_number;
            }

            Vector3r gaussian_noise(Vector3r clean_numbers, Vector3r means, Vector3r variances)
            {
                real_T dirty_number_x = gaussian_noise(clean_numbers.x(), means.x(), variances.x());
                real_T dirty_number_y = gaussian_noise(clean_numbers.y(), means.y(), variances.y());
                real_T dirty_number_z = gaussian_noise(clean_numbers.z(), means.z(), variances.z());
                Vector3r dirty_number(dirty_number_x, dirty_number_y, dirty_number_z);
                return dirty_number;
            }

            real_T apply_process_noise(real_T clean_number, real_T mean, real_T variance)
            {
                if (activate_process_noise)
                {
                    real_T dirty_number = gaussian_noise(clean_number, mean, variance);
                    return dirty_number;
                }
                else
                {
                    return clean_number;
                }
            }

            Vector3r apply_process_noise(Vector3r clean_number, Vector3r mean, Vector3r variance)
            {
                if (activate_process_noise)
                {
                    Vector3r dirty_number = gaussian_noise(clean_number, mean, variance);
                    return dirty_number;
                }
                else
                {
                    return clean_number;
                }
            }

            void getNextKinematicsNoCollisionBB2(TTimeDelta dt, PhysicsBody& body, const Kinematics::State& current,
                Kinematics::State& next, Wrench& next_wrench, const Vector3r& wind, float prop_damage[])
            {
                const real_T dt_real = static_cast<real_T>(dt);
                Vector3r avg_linear;
                Vector3r avg_angular;
                if (use_average_values)
                {
                    avg_linear = current.twist.linear + current.accelerations.linear * (0.5f * dt_real);
                    avg_angular = current.twist.angular + current.accelerations.angular * (0.5f * dt_real);
                }
                else
                {
                    avg_linear = current.twist.linear;
                    avg_angular = current.twist.angular;
                }
                

                std::vector<real_T> PWMs = body.getPWMrotors_INDI(previous);

                real_T omega1 = PWMs[0];
                if (omega1 <= 1) { omega1 = 0.0f; }
                real_T omega2 = PWMs[1];
                if (omega2 <= 1) { omega2 = 0.0f; }
                real_T omega3 = PWMs[2];
                if (omega3 <= 1) { omega3 = 0.0f; }
                real_T omega4 = PWMs[3];
                if (omega4 <= 1) { omega4 = 0.0f; }

                // Correct body mass and inertia
                real_T n_broken_prop = 0;
                for (int i = 0; i < 4; i++)
                {
                    if (PWMs[i] < 1)
                    {
                        n_broken_prop++;
                    }
                }
                body.choose_inertia(n_broken_prop, b, l);

                // Circular area descibed by the rotating propeller
                real_T Area = M_PIf * R * R;

                // Velocity of the drone
                // Use relative velocity of the body wrt wind
                const Vector3r relative_vel = avg_linear - wind;
                const Vector3r linear_vel_body = VectorMath::transformToBodyFrame(relative_vel, current.pose.orientation);
                real_T u = linear_vel_body.x();
                real_T v = linear_vel_body.y();
                real_T w = linear_vel_body.z();
                std::vector<real_T> V{ u , v , w };
                real_T Va = sqrt(u * u + v * v + w * w);

                // Obtain the angle of attack
                real_T alpha;
                if (Va >= 0.01)
                {
                    alpha = asin(w / Va) * rad2deg_factor;
                }
                else
                {
                    alpha = 0.0f;
                }

                // Normal force from the static wind tunnel test
                static std::vector<real_T> AoA_airframe{ 90.0f, 75.0f, 60.0f, 45.0f, 30.0f, 15.0f, 0.0f, -15.0f, -30.0f, -45.0f, -75.0f, -90.0f };
                static std::vector<real_T> Cz_airframe{ -0.0115, -0.0124, -0.0137, -0.0128, -0.0100, -0.0063, 0.0014, 0.0045, 0.007, 0.0094, 0.0119, 0.0120 };
                if (AoA_airframe[0] > AoA_airframe[1])
                {
                    std::reverse(AoA_airframe.begin(), AoA_airframe.end());
                    std::reverse(Cz_airframe.begin(), Cz_airframe.end());
                }

                real_T CN_airframe = interp1(AoA_airframe, Cz_airframe, alpha);
                real_T T0 = -CN_airframe * Va * 2.0f;

                // normal force correctness from the flight data
                real_T w_constraint = w;
                if (w_constraint <= -6)
                {
                    w_constraint = -6.0f;
                }
                else if (w_constraint > 2)
                {
                    w_constraint = 2.0f;
                }
                real_T u_constraint = u;
                real_T v_constraint = v;
                real_T uv_scale = 8.0f / sqrt(u * u + v * v);
                if (uv_scale <= 1)
                {
                    u_constraint = uv_scale * u;
                    v_constraint = uv_scale * v;
                }
                std::vector<real_T> AT0 = P33(u_constraint, abs(v_constraint), w_constraint);
                std::vector<real_T> k_model_1{ -0.0463911782738117, 0.126912947052739, 0.324191845756361, -0.0557628235059462, 0.00571250782560552, -0.103210100621382, -0.0146821184410235, 0.0199520548034235, -0.138168259069616, 0.0273216857565274, -0.00105647803825825, 0.00634522471334950, 0.00166114145301890, -0.00689017065134193, -0.00104094928681998, -0.00176014569852436, 0.00304889473917665, 0.00866535042034273, -0.00554316427701624, -0.0137422347201967 };
                real_T T_corr = std::inner_product(AT0.begin(), AT0.end(), k_model_1.begin(), 0.0);

                // Calculate Ctand Cq of each rotor
                std::vector<int> SL{ 1, -1, -1, 1 };
                std::vector<int> SM{ 1, 1, -1, -1 };
                std::vector<int> SN{ signr * 1, signr * -1, signr * 1, signr * -1 };

                Vector3r d1(l, -b, 0.0f);
                Vector3r d2(l, b, 0.0f);
                Vector3r d3(-l, b, 0.0f);
                Vector3r d4(-l, -b, 0.0f);

                // The speed in u, vand w experienced by each rotor
                Vector3r V1 = avg_angular.cross(d1) + linear_vel_body;
                Vector3r V2 = avg_angular.cross(d2) + linear_vel_body;
                Vector3r V3 = avg_angular.cross(d3) + linear_vel_body;
                Vector3r V4 = avg_angular.cross(d4) + linear_vel_body;

                // The speed in u, vand w experienced by each rotor
                real_T u1 = V1.x(); real_T v1 = V1.y(); real_T w1 = V1.z();
                real_T u2 = V2.x(); real_T v2 = V2.y(); real_T w2 = V2.z();
                real_T u3 = V3.x(); real_T v3 = V3.y(); real_T w3 = V3.z();
                real_T u4 = V4.x(); real_T v4 = V4.y(); real_T w4 = V4.z();

                // Airspeed experienced by each rotor
                real_T va1 = sqrt(u1 * u1 + v1 * v1 + w1 * w1);
                real_T va2 = sqrt(u2 * u2 + v2 * v2 + w2 * w2);
                real_T va3 = sqrt(u3 * u3 + v3 * v3 + w3 * w3);
                real_T va4 = sqrt(u4 * u4 + v4 * v4 + w4 * w4);

                // Computation of the advance ratio
                real_T vv1 = va1 / (omega1 * R);
                if (isnan(vv1) || isinf(abs(vv1))) { vv1 = 0.0f; }
                if (vv1 >= 0.6) { vv1 = 0.6; }

                real_T vv2 = va2 / (omega2 * R);
                if (isnan(vv2) || isinf(abs(vv2))) { vv2 = 0.0f; }
                if (vv2 >= 0.6) { vv2 = 0.6; }

                real_T vv3 = va3 / (omega3 * R);
                if (isnan(vv3) || isinf(abs(vv3))) { vv3 = 0.0f; }
                if (vv3 >= 0.6) { vv3 = 0.6; }

                real_T vv4 = va4 / (omega4 * R);
                if (isnan(vv4) || isinf(abs(vv4))) { vv4 = 0.0f; }
                if (vv4 >= 0.6) { vv4 = 0.6; }

                // Computation of the angle of attack of each propeller
                real_T alpha1 = atan(w1 / sqrt(u1 * u1 + v1 * v1)) * rad2deg_factor;
                if (isnan(alpha1) || isinf(abs(alpha1))) { alpha1 = 0.0f; }

                real_T alpha2 = atan(w2 / sqrt(u2 * u2 + v2 * v2)) * rad2deg_factor;
                if (isnan(alpha2) || isinf(abs(alpha2))) { alpha2 = 0.0f; }

                real_T alpha3 = atan(w3 / sqrt(u3 * u3 + v3 * v3)) * rad2deg_factor;
                if (isnan(alpha3) || isinf(abs(alpha3))) { alpha3 = 0.0f; }

                real_T alpha4 = atan(w4 / sqrt(u4 * u4 + v4 * v4)) * rad2deg_factor;
                if (isnan(alpha4) || isinf(abs(alpha4))) { alpha4 = 0.0f; }

                // The density times the square of the radius of the propeller times the
                // square of the rotational speed
                real_T rhoRR = rho * R * R;
                real_T dynhead1 = rhoRR * omega1 * omega1;
                real_T dynhead2 = rhoRR * omega2 * omega2;
                real_T dynhead3 = rhoRR * omega3 * omega3;
                real_T dynhead4 = rhoRR * omega4 * omega4;

                // Ct0 and Cq0 from the static wind tunnel test data
                // Ct is used for the thrust of the rotor.Ct0X is a function of the angle
                // of attack of the bladeand the advance ratio.The relation between these
                // quantities is approximated by a 5th degree order polynomial that use the
                // blade angle of attack and the advance ratio as parameters, multiplied by
                // SI coefficients under the name K_Ct0.The explanation can be found in the
                // paper "Aerodynamic Model Identification of a Quadrotor Subjected to Rotor
                // Failures in the High - Speed Flight Regime", Equation 9.
                std::vector<real_T> k_Ct0{ 0.0152457017219075, -3.19835880466424e-05, -0.0474659629880834, -5.48089604291955e-08, -0.000164550969624146, 0.650877249185920, 1.10477778832442e-08, -9.76752919452344e-06, 0.00859691522825337, -2.20418122442645, 3.27434126987218e-11, -5.69117054658112e-08, 2.32561854294217e-05, -0.0116550184566165, 3.04959484433102, -6.00795185558617e-13, 1.81690349314076e-10, -4.63671043348055e-08, -1.52454780569063e-05, 0.00607313609112646, -1.51563942225535 };

                std::vector<real_T> Ct01_P52 = P52(alpha1, vv1);
                real_T Ct01 = std::inner_product(Ct01_P52.begin(), Ct01_P52.end(), k_Ct0.begin(), 0.0);

                std::vector<real_T> Ct02_P52 = P52(alpha2, vv2);
                real_T Ct02 = std::inner_product(Ct02_P52.begin(), Ct02_P52.end(), k_Ct0.begin(), 0.0);

                std::vector<real_T> Ct03_P52 = P52(alpha3, vv3);
                real_T Ct03 = std::inner_product(Ct03_P52.begin(), Ct03_P52.end(), k_Ct0.begin(), 0.0);

                std::vector<real_T> Ct04_P52 = P52(alpha4, vv4);
                real_T Ct04 = std::inner_product(Ct04_P52.begin(), Ct04_P52.end(), k_Ct0.begin(), 0.0);

                // Cq is used for the drag torque of the rotor
                std::vector<real_T> k_Cq0{ -0.000166978387654207, -9.26661647846620e-07, -0.000161106517356852, 1.49219451037256e-09, -2.80468068962665e-06, 0.000591396065463947, 4.46363200546300e-10, 8.90349145739088e-08, -1.53880349952214e-05, -0.00773976740405967, -3.70391296926118e-13, 3.92836511888492e-10, -1.33297247718639e-08, -0.000133549679393062, 0.0164947421115812, -4.17586454158575e-14, -3.24864794974322e-12, 1.14205811263298e-09, -6.42233810561959e-08, 0.000149532607712236, -0.0106110955476936 };

                real_T Cq01 = std::inner_product(Ct01_P52.begin(), Ct01_P52.end(), k_Cq0.begin(), 0.0);
                real_T Cq02 = std::inner_product(Ct02_P52.begin(), Ct02_P52.end(), k_Cq0.begin(), 0.0);
                real_T Cq03 = std::inner_product(Ct03_P52.begin(), Ct03_P52.end(), k_Cq0.begin(), 0.0);
                real_T Cq04 = std::inner_product(Ct04_P52.begin(), Ct04_P52.end(), k_Cq0.begin(), 0.0);

                // Similar to the angle of attack equation-- > horizontal advance ratio.The
                // explanation of this quantity is found in the paper "Aerodynamic Model 
                // Identification of a Quadrotor Subjected to Rotor Failures in the
                // High - Speed Flight Regime", Equation 20.
                real_T mu1 = sqrt(u1 * u1 + v1 * v1) / (omega1 * R);
                if (isnan(mu1) || isinf(abs(mu1))) { mu1 = 0.0f; }
                real_T mu2 = sqrt(u2 * u2 + v2 * v2) / (omega2 * R);
                if (isnan(mu2) || isinf(abs(mu2))) { mu2 = 0.0f; }
                real_T mu3 = sqrt(u3 * u3 + v3 * v3) / (omega3 * R);
                if (isnan(mu3) || isinf(abs(mu3))) { mu3 = 0.0f; }
                real_T mu4 = sqrt(u4 * u4 + v4 * v4) / (omega4 * R);
                if (isnan(mu4) || isinf(abs(mu4))) { mu4 = 0.0f; }

                // Similar to the sideslipe angle equation
                real_T lc1 = w1 / (omega1 * R);
                if (isnan(lc1) || isinf(abs(lc1))) { lc1 = 0.0f; }
                real_T lc2 = w2 / (omega2 * R);
                if (isnan(lc2) || isinf(abs(lc2))) { lc2 = 0.0f; }
                real_T lc3 = w3 / (omega3 * R);
                if (isnan(lc3) || isinf(abs(lc3))) { lc3 = 0.0f; }
                real_T lc4 = w4 / (omega4 * R);
                if (isnan(lc4) || isinf(abs(lc4))) { lc4 = 0.0f; }

                real_T dCt_1 = 0.0f;
                real_T dCt_2 = 0.0f;
                real_T dCt_3 = 0.0f;
                real_T dCt_4 = 0.0f;
                                
                real_T dCq_1 = 0.0f;
                real_T dCq_2 = 0.0f;
                real_T dCq_3 = 0.0f;
                real_T dCq_4 = 0.0f;

                if (!(u == 0 && v == 0))
                {
                    real_T beta = calc_beta2(u, v);
                    real_T arm_angle = atan(l / b);
                    real_T psi_h1 = (beta - (5.0f * M_PIf / 2.0f - arm_angle));
                    real_T psi_h2 = (beta - (3.0f * M_PIf / 2.0f + arm_angle));
                    real_T psi_h3 = (beta - (3.0f * M_PIf / 2.0f - arm_angle));
                    real_T psi_h4 = (beta - (M_PIf / 2.0f + arm_angle));

                    psi_h1 = matlabFmod(psi_h1, 2.0f * M_PIf);
                    psi_h2 = matlabFmod(psi_h2, 2.0f * M_PIf);
                    psi_h3 = matlabFmod(psi_h3, 2.0f * M_PIf);
                    psi_h4 = matlabFmod(psi_h4, 2.0f * M_PIf);

                    //psi_h1 = std::floor(psi_h1 * 100000) / 100000;
                    //psi_h2 = std::floor((2 * M_PIf - psi_h2) * 100000) / 100000;
                    //psi_h3 = std::floor(psi_h3 * 100000) / 100000;
                    //psi_h4 = std::floor((2 * M_PIf - psi_h4) * 100000) / 100000;

                    psi_h2 = 2.0f * M_PIf - psi_h2;
                    psi_h4 = 2.0f * M_PIf - psi_h4;

                    // calculate dCt and dCq using model identified from the flight data
                    std::vector<real_T> k_model_2{ 0.00274750362242118, 0.0587325418628517, 0.0291979006795257, 0.155176381977433, -0.848919654295447, -2.85285652127970, -16.6872606424138, -25.3582092758054, -8.21139486023900, 0.000662666074942486, -0.0137515544490184, 0.0258468383560923, 0.129354278831284, 0.739022953068088, -0.751589665006720, 2.30225029828906, 3.19387485842342, -2.01400124775404, -0.0327090226346993, 0.00550048663001955, 0.704747484311295, 0.384042859177342, 0.409107040799852, -2.91693142809590, -5.72731924259749, -3.84424311448819, 0.957068915766478, 0.00798767042006989, -0.0658174319226979, -0.515362725845307, 0.154017181898898, 1.07229345471127, 5.60834749404815, 3.12341580631406, 13.2751387862931, 3.38340384818304, -0.00871325200163225, 0.0139319909808224, 0.135829051260073, 0.0724018634704221, 0.462231305873754, 1.07728548843851, -2.92439099099261, 2.07387265629944, -1.76236683822441, 0.00277901355913424, 5.93712461960435e-05, -0.0737682036851551, 0.408392701436168, 0.181780336855863, -0.0914796558508702, -5.33048488631146, -11.6294693255163, -4.72950404100762, -0.00594871416216384, -0.0162850806730608, 0.173368295316786, 0.186292675296392, 0.225644067201894, -0.688845939593434, -6.49432628543192, -7.80900137821226, 0.415239218701371, -0.00544216811616573, 0.00518487316578840, 0.0476580090813803, -0.200801241660794, -0.476117215479456, -0.407991135460875, -1.81735072025647, 1.50472930028764, 4.35662490484023, -0.00159368739623987, 0.000467723919419556, 0.0129022985413385, -0.142747208717601, -0.286423056758624, -0.233246678589007, 5.27930446169201, 6.06363387971617, 3.14128857337644, 0.00453268191002699, -0.00474962613583822, -0.180460224377998, -0.0116017180130748, 0.0192198318847662, 1.17708508701190, 0.0640467785184096, 3.10723451211166, 0.482465692101886 };
                    std::vector<real_T> k_model_11{ 0.00260329204354066, 0.00129328992586148, -0.0199809965492002, -0.0868022523710462, -0.0889469386700429, 0.128032771798353, 0.146886709138850, 0.524080931866815, 0.725843471299357, 0.00242937984350116, -0.00310550867822261, -0.0595768021706452, 0.0523222113704624, 0.0799385477524136, 0.0802433226135493, 0.387865290852874, 0.137337555435232, -0.310321282567866, 0.00158155254379188, 0.00319704874615568, -0.0554013498676434, -0.133883081875846, -0.154861909695999, 0.246917675390354, 0.0807388330437734, 1.21408540541708, 0.991981880292023, -9.00820660019962e-05, 0.000417739287775632, -0.00176625889617756, -0.0352354581017755, 0.00347023118130632, -0.0818779712415576, -0.0939352353976481, 0.367104057232038, -0.239846676494934, 0.000548702590051651, 0.000217200486637933, -0.00564899836836745, -0.000264397140190192, 0.00896129402789547, -0.0942019724552947, 0.0408551476683280, 0.607021266741172, 0.0144874105803823, 0.000847230370183477, -0.000948252583147180, -0.00265605533100469, 0.0598956109168678, 0.0807953120897514, -0.0545778293654141, -0.235368707057857, -0.948022031763549, -0.608815444932934, -0.000182959785330574, 0.00167139842657429, 0.00833552390363391, 0.0167067780351973, -0.00216159653990414, -0.0668352653475071, 0.0332682896037231, -0.220002714254035, -0.100740744918869, -0.000459348737065979, -0.00323901937377689, 0.0150989940672047, -0.00337931488830346, 0.0705271437626767, -0.0355357034004435, -0.0945407727921580, -0.114237238851565, -0.348109605269992, -0.000423056934179010, -1.57962640331396e-05, 0.00625198744041810, -0.0204741957877981, -0.00655890452523322, -0.0335286749006157, 0.0745650825531103, 0.0289036906676707, -0.0296758936977819, -0.000231091410645385, -0.000748657303930713, 0.00208598921233990, -0.0132023573075178, 0.0116429676033409, 0.0151697188209396, -0.0404565223580964, 0.178329482629743, 0.0297489549373982 };

                    std::vector<real_T> Fn1 = Fn(psi_h1, h, 0.0f, 1.0f, mu1, lc1);
                    std::vector<real_T> Fn2 = Fn(psi_h2, h, 0.0f, 1.0f, mu2, lc2);
                    std::vector<real_T> Fn3 = Fn(psi_h3, h, 0.0f, 1.0f, mu3, lc3);
                    std::vector<real_T> Fn4 = Fn(psi_h4, h, 0.0f, 1.0f, mu4, lc4);

                    dCt_1 = std::inner_product(Fn1.begin(), Fn1.end(), k_model_2.begin(), 0.0);
                    dCt_2 = std::inner_product(Fn2.begin(), Fn2.end(), k_model_2.begin(), 0.0);
                    dCt_3 = std::inner_product(Fn3.begin(), Fn3.end(), k_model_2.begin(), 0.0);
                    dCt_4 = std::inner_product(Fn4.begin(), Fn4.end(), k_model_2.begin(), 0.0);

                    dCq_1 = std::inner_product(Fn1.begin(), Fn1.end(), k_model_11.begin(), 0.0);
                    dCq_2 = std::inner_product(Fn2.begin(), Fn2.end(), k_model_11.begin(), 0.0);
                    dCq_3 = std::inner_product(Fn3.begin(), Fn3.end(), k_model_11.begin(), 0.0);
                    dCq_4 = std::inner_product(Fn4.begin(), Fn4.end(), k_model_11.begin(), 0.0);
                }

                // saturate dCt and dCq for extrapolation
                if (dCt_1 > 0.007) { dCt_1 = 0.007; }
                else if (dCt_1 < -0.007) { dCt_1 = -0.007; }
                if (dCt_2 > 0.007) { dCt_2 = 0.007; }
                else if (dCt_2 < -0.007) { dCt_2 = -0.007; }
                if (dCt_3 > 0.007) { dCt_3 = 0.007; }
                else if (dCt_3 < -0.007) { dCt_3 = -0.007; }
                if (dCt_4 > 0.007) { dCt_4 = 0.007; }
                else if (dCt_4 < -0.007) { dCt_4 = -0.007; }

                if (dCq_1 > 0.0001) { dCq_1 = 0.0001; }
                else if (dCq_1 < -0.0007) { dCq_1 = -0.0007; }
                if (dCq_2 > 0.0001) { dCq_2 = 0.0001; }
                else if (dCq_2 < -0.0007) { dCq_2 = -0.0007; }
                if (dCq_3 > 0.0001) { dCq_3 = 0.0001; }
                else if (dCq_3 < -0.0007) { dCq_3 = -0.0007; }
                if (dCq_4 > 0.0001) { dCq_4 = 0.0001; }
                else if (dCq_4 < -0.0007) { dCq_4 = -0.0007; }

                // interaction effect is negligible when V < 2m / s;
                real_T vh = sqrt(u * u + v * v);
                real_T one_exp = 1.0f / (1.0f + exp(-6.0f * (vh - 1.0f)));
                dCt_1 = one_exp * dCt_1;
                dCt_2 = one_exp * dCt_2;
                dCt_3 = one_exp * dCt_3;
                dCt_4 = one_exp * dCt_4;
                        
                dCq_1 = one_exp * dCq_1;
                dCq_2 = one_exp * dCq_2;
                dCq_3 = one_exp * dCq_3;
                dCq_4 = one_exp * dCq_4;

                // Forces and moments of each rotor
                // The following equations compute the thrust of each motor.The equations
                // are obtained from the paper "Multirotor Aerial Vehicles: Modeling,
                // Estimation and Control of Quadrotor", Equation 2. This equation can also
                // be found in the book of "Basic Helicopter Aerodynamics", between
                // Equations 2.4 and 2.5
                real_T T1 = (Ct01 + dCt_1) * dynhead1 * Area;
                real_T T2 = (Ct02 + dCt_2) * dynhead2 * Area;
                real_T T3 = (Ct03 + dCt_3) * dynhead3 * Area;
                real_T T4 = (Ct04 + dCt_4) * dynhead4 * Area;

                // Computation of the forces in the x - direction.It is explained in Equation
                // 23 of the paper "Aerodynamic Model Identification of a Quadrotor 
                // Subjected to Rotor Failures in the High - Speed Flight Regime"
                real_T k_model_3 = -4.18219980688138e-05;
                real_T k_model_4 = 2.75369651421482e-05;
                real_T X1 = u1 * omega1 * k_model_3 + SN[0] * v1 * omega1 * k_model_4;
                real_T X2 = u2 * omega2 * k_model_3 + SN[1] * v2 * omega2 * k_model_4;
                real_T X3 = u3 * omega3 * k_model_3 + SN[2] * v3 * omega3 * k_model_4;
                real_T X4 = u4 * omega4 * k_model_3 + SN[3] * v4 * omega4 * k_model_4;

                // Computation of the forces in the y - direction.It is explained in Equation
                // 23 of the paper "Aerodynamic Model Identification of a Quadrotor 
                // Subjected to Rotor Failures in the High - Speed Flight Regime"
                real_T k_model_5 = -5.43414653058895e-05;
                real_T k_model_6 = -1.34375303328745e-05;
                real_T Y1 = SN[0] * u1 * omega1 * k_model_6 + v1 * omega1 * k_model_5;
                real_T Y2 = SN[1] * u2 * omega2 * k_model_6 + v2 * omega2 * k_model_5;
                real_T Y3 = SN[2] * u3 * omega3 * k_model_6 + v3 * omega3 * k_model_5;
                real_T Y4 = SN[3] * u4 * omega4 * k_model_6 + v4 * omega4 * k_model_5;

                // Computation of moments around the x axis.It is explained in Equation
                // 24 of the paper "Aerodynamic Model Identification of a Quadrotor 
                // Subjected to Rotor Failures in the High - Speed Flight Regime"
                real_T k_model_7 = -6.49293933727443e-06;
                real_T k_model_8 = 1.99308688196749e-06;
                real_T L1 = SN[0] * u1 * omega1 * k_model_8 + v1 * omega1 * k_model_7;
                real_T L2 = SN[1] * u2 * omega2 * k_model_8 + v2 * omega2 * k_model_7;
                real_T L3 = SN[2] * u3 * omega3 * k_model_8 + v3 * omega3 * k_model_7;
                real_T L4 = SN[3] * u4 * omega4 * k_model_8 + v4 * omega4 * k_model_7;

                // Computation of moments around the y axis.It is explained in Equation
                // 24 of the paper "Aerodynamic Model Identification of a Quadrotor 
                // Subjected to Rotor Failures in the High - Speed Flight Regime"
                real_T k_model_9 = 3.95678611524143e-06;
                real_T k_model_10 = 2.78425962530407e-07;
                real_T M1 = u1 * omega1 * k_model_9 + SN[0] * v1 * omega1 * k_model_10;
                real_T M2 = u2 * omega2 * k_model_9 + SN[1] * v2 * omega2 * k_model_10;
                real_T M3 = u3 * omega3 * k_model_9 + SN[2] * v3 * omega3 * k_model_10;
                real_T M4 = u4 * omega4 * k_model_9 + SN[3] * v4 * omega4 * k_model_10;

                // Computation of moments around the z axis.When applied to the propellers,
                // it would be the drag torque.I think it is missing a factor of the
                // propeller radius, as can be seen from equation 7 in the paper
                // "Aerodynamic Model Identification of a Quadrotor Subjected to Rotor
                // Failures in the High - Speed Flight Regime"
                real_T N1 = SN[0] * (Cq01 + dCq_1) * dynhead1 * Area;
                real_T N2 = SN[1] * (Cq02 + dCq_2) * dynhead2 * Area;
                real_T N3 = SN[2] * (Cq03 + dCq_3) * dynhead3 * Area;
                real_T N4 = SN[3] * (Cq04 + dCq_4) * dynhead4 * Area;

                real_T T = T0 + T1 + T2 + T3 + T4 + T_corr;
                real_T Fx = X1 + X2 + X3 + X4;
                real_T Fy = Y1 + Y2 + Y3 + Y4;

                // When computing the moments, first the forces are taken into
                // consideration, followed by all the moments or torques.In the case of
                // moments in the z - direction, the xand y forces both have an effect.band
                // l are the distances in the yand x direction respectively to the center
                // of gravity from each propeller.
                real_T Mx = SL[0] * b * T1 + SL[1] * b * T2 + SL[2] * b * T3 + SL[3] * b * T4 + L1 + L2 + L3 + L4;
                real_T My = SM[0] * l * T1 + SM[1] * l * T2 + SM[2] * l * T3 + SM[3] * l * T4 + M1 + M2 + M3 + M4;
                real_T Mz = b * SL[0] * X1 + b * SL[1] * X2 + b * SL[2] * X3 + b * SL[3] * X4 + l * SM[0] * Y1 + l * SM[1] * Y2 + l * SM[2] * Y3 + l * SM[3] * Y4 + N1 + N2 + N3 + N4;

                // Obtain the force and moment vector
                Wrench wrench = Wrench::zero();
                Vector3r local_force = Vector3r(Fx, Fy, -T);
                Vector3r local_torque = Vector3r(Mx, My, Mz);
                wrench.force = local_force;
                wrench.torque = local_torque;

                //convert force to world frame, leave torque to local frame
                wrench.force = VectorMath::transformToWorldFrame(wrench.force, current.pose.orientation);

                if (body.isGrounded()) {
                    // make it stick to the ground until the magnitude of net external force on body exceeds its weight.
                    float external_force_magnitude = wrench.force.squaredNorm();
                    Vector3r weight = body.getMass() * body.getEnvironment().getState().gravity;
                    float weight_magnitude = weight.squaredNorm();
                    if (external_force_magnitude >= weight_magnitude)
                    {
                        body.setGrounded(false);
                    }
                    next_wrench.force = Vector3r::Zero();
                    next_wrench.torque = Vector3r::Zero();
                    next.accelerations.linear = Vector3r::Zero();
                }
                else {
                    next_wrench = wrench;

                    /************************* Update accelerations due to force and torque ************************/
                    //get new acceleration due to force - we'll use this acceleration in next time step
                    // Transform to the body frame the linear velocity of the body
                    const Vector3r Vb = VectorMath::transformToBodyFrame(avg_linear, current.pose.orientation);

                    // Compute the cross product of the angular velocities and the body linear velocities in the body frame.
                    Vector3r Vb_pqr_cross = avg_angular.cross(Vb);

                    // Convert back to WorldFrame format
                    Vb_pqr_cross = VectorMath::transformToWorldFrame(Vb_pqr_cross, current.pose.orientation);

                    // Compute the next linear accelerations
                    next.accelerations.linear = apply_process_noise((next_wrench.force / body.getMass()) + body.getEnvironment().getState().gravity - Vb_pqr_cross, mean_vxyz, cov_vxyz);

                }

                if (body.isGrounded()) {
                    // this stops vehicle from vibrating while it is on the ground doing nothing.
                    next.accelerations.angular = Vector3r::Zero();
                    next.twist.linear = Vector3r::Zero();
                    next.twist.angular = Vector3r::Zero();
                }
                else {
                    //get new angular acceleration
                    //Euler's rotation equation: https://en.wikipedia.org/wiki/Euler's_equations_(body_dynamics)
                    //we will use torque to find out the angular acceleration
                    //angular momentum L = I * omega
                    const Vector3r angular_momentum = body.getInertia() * avg_angular;

                    // The gyroscopic moment has to be computed
                    // First the propeller Moment of Inertia is established
                    Matrix3x3r Ip = Matrix3x3r::Zero();
                    Ip(0, 0) = 4.2e-06; Ip(0, 1) = 0.0f; Ip(0, 2) = 0.0f;
                    Ip(1, 0) = 0.0f; Ip(1, 1) = 4.2e-06; Ip(1, 2) = 0.0f;
                    Ip(2, 0) = 0.0f; Ip(2, 1) = 0.0f; Ip(2, 2) = 8.0e-06;

                    // Then the gryoscopic part of the moment
                    const Vector3r w1_vector = Vector3r(0.0f, 0.0f, omega1);
                    const Vector3r w2_vector = Vector3r(0.0f, 0.0f, -omega2);
                    const Vector3r w3_vector = Vector3r(0.0f, 0.0f, omega3);
                    const Vector3r w4_vector = Vector3r(0.0f, 0.0f, -omega4);
                    const Vector3r M_gyro_second = avg_angular.cross(Ip * w1_vector + Ip * w2_vector + Ip * w3_vector + Ip * w4_vector);

                    real_T omega1_dot = (omega1 - omega1_last) / dt_real;
                    real_T omega2_dot = (omega2 - omega2_last) / dt_real;
                    real_T omega3_dot = (omega3 - omega3_last) / dt_real;
                    real_T omega4_dot = (omega4 - omega4_last) / dt_real;
                    const Vector3r w1_dot_vector = Vector3r(0.0f, 0.0f, omega1_dot);
                    const Vector3r w2_dot_vector = Vector3r(0.0f, 0.0f, -omega2_dot);
                    const Vector3r w3_dot_vector = Vector3r(0.0f, 0.0f, omega3_dot);
                    const Vector3r w4_dot_vector = Vector3r(0.0f, 0.0f, -omega4_dot);
                    const Vector3r M_gyro_first = Ip * w1_dot_vector + Ip * w2_dot_vector + Ip * w3_dot_vector + Ip * w4_dot_vector;

                    omega1_last = omega1;
                    omega2_last = omega2;
                    omega3_last = omega3;
                    omega4_last = omega4;


                    const Vector3r M_gyro = signr * (M_gyro_first + M_gyro_second);
                    const Vector3r angular_momentum_rate = next_wrench.torque - M_gyro - avg_angular.cross(angular_momentum);
                    //new angular acceleration - we'll use this acceleration in next time step
                    next.accelerations.angular = apply_process_noise(body.getInertiaInv() * angular_momentum_rate, mean_pqr, cov_pqr);

                    /************************* Update pose and twist after dt ************************/
                    //Verlet integration: http://www.physics.udel.edu/~bnikolic/teaching/phys660/numerical_ode/node5.html
                    // ode2 Heuns method
                    if (integration_method_v == 0)  // Verlet algorithm
                    {
                        next.twist.linear = apply_process_noise(current.twist.linear + (current.accelerations.linear + next.accelerations.linear) * (0.5f * dt_real), mean_xyz, cov_xyz);
                        next.twist.angular = apply_process_noise(current.twist.angular + (current.accelerations.angular + next.accelerations.angular) * (0.5f * dt_real), mean_att, cov_att);
                    }
                    else if (integration_method_v == 1)  // Verlet algorithm AirSim
                    {
                        next.twist.linear = apply_process_noise(current.twist.linear + next.accelerations.linear * dt_real + (current.accelerations.linear) * (0.5f * dt_real), mean_xyz, cov_xyz);
                        next.twist.angular = apply_process_noise(current.twist.angular + next.accelerations.angular * dt_real + (current.accelerations.angular) * (0.5f * dt_real), mean_att, cov_att);
                    }
                    else if (integration_method_v == 2)  // Adams-Bashfort 2-step method
                    {
                        next.twist.linear = apply_process_noise(current.twist.linear + 3 / 2.0f * next.accelerations.linear * dt_real - current.accelerations.linear * (0.5f * dt_real), mean_xyz, cov_xyz);
                        next.twist.angular = apply_process_noise(current.twist.angular + 3 / 2.0f * next.accelerations.angular * dt_real - current.accelerations.angular * (0.5f * dt_real), mean_att, cov_att);
                    }
                    else if (integration_method_v == 3)  // Beeman and Schofield
                    {
                        next.twist.linear = apply_process_noise(current.twist.linear + 1 / 6.0f * (2 * next.accelerations.linear + 5 * current.accelerations.linear - previous.accelerations.linear) * dt_real, mean_xyz, cov_xyz);
                        next.twist.angular = apply_process_noise(current.twist.angular + 1 / 6.0f * (2 * next.accelerations.angular + 5 * current.accelerations.angular - previous.accelerations.angular) * dt_real, mean_att, cov_att);
                    }

                    real_T vx_print = abs(next.twist.linear.x());
                    real_T vy_print = abs(next.twist.linear.y());
                    real_T vz_print = abs(next.twist.linear.z());
                    real_T p_print = abs(next.twist.angular.x());
                    real_T q_print = abs(next.twist.angular.y());
                    real_T r_print = abs(next.twist.angular.z());

                    //if controller has bug, velocities can increase idenfinitely 
                    //so we need to clip this or everything will turn in to infinity/nans

                    if (next.twist.linear.squaredNorm() > EarthUtils::SpeedOfLight * EarthUtils::SpeedOfLight) { //speed of light
                        next.twist.linear /= (next.twist.linear.norm() / EarthUtils::SpeedOfLight);
                        next.accelerations.linear = Vector3r::Zero();
                    }
                    //
                    //for disc of 1m radius which angular velocity translates to speed of light on tangent?
                    if (next.twist.angular.squaredNorm() > EarthUtils::SpeedOfLight * EarthUtils::SpeedOfLight) { //speed of light
                        next.twist.angular /= (next.twist.angular.norm() / EarthUtils::SpeedOfLight);
                        next.accelerations.angular = Vector3r::Zero();
                    }
                }
                real_T x_location = current.pose.position.x();
                real_T z_location = current.pose.position.z();
                computeNextPose(dt, current, next);
            }
            void getNextKinematicsNoCollision(TTimeDelta dt, PhysicsBody& body, const Kinematics::State& current,
                Kinematics::State& next, Wrench& next_wrench, const Vector3r& wind, float prop_damage[])
            {
                const real_T dt_real = static_cast<real_T>(dt);

                Vector3r avg_linear = Vector3r::Zero();
                Vector3r avg_angular = Vector3r::Zero();

                /************************* Get force and torque acting on body ************************/
                //set wrench sum to zero
                const Wrench body_wrench = getBodyWrench(body, current.pose.orientation, prop_damage);

                if (body.isGrounded()) {
                    // make it stick to the ground until the magnitude of net external force on body exceeds its weight.
                    float external_force_magnitude = body_wrench.force.squaredNorm();
                    Vector3r weight = body.getMass() * body.getEnvironment().getState().gravity;
                    float weight_magnitude = weight.squaredNorm();
                    if (external_force_magnitude >= weight_magnitude)
                    {
                        //throttledLogOutput("*** Losing ground lock due to body_wrench " + VectorMath::toString(body_wrench.force), 0.1);
                        body.setGrounded(false);
                    }
                    next_wrench.force = Vector3r::Zero();
                    next_wrench.torque = Vector3r::Zero();
                    next.accelerations.linear = Vector3r::Zero();
                }
                else {
                    //add linear drag due to velocity we had since last dt seconds + wind
                    //drag vector magnitude is proportional to v^2, direction opposite of velocity
                    //total drag is b*v + c*v*v but we ignore the first term as b << c (pg 44, Classical Mechanics, John Taylor)
                    //To find the drag force, we find the magnitude in the body frame and unit vector direction in world frame
                    avg_linear = current.twist.linear + current.accelerations.linear * (0.5f * dt_real);
                    avg_angular = current.twist.angular + current.accelerations.angular * (0.5f * dt_real);
                    const Wrench drag_wrench = getDragWrench(body, current.pose.orientation, avg_linear, avg_angular, wind);

                    next_wrench = body_wrench + drag_wrench;

                    //Utils::log(Utils::stringf("B-WRN %s: ", VectorMath::toString(body_wrench.force).c_str()));
                    //Utils::log(Utils::stringf("D-WRN %s: ", VectorMath::toString(drag_wrench.force).c_str()));

                    /************************* Update accelerations due to force and torque ************************/
                    //get new acceleration due to force - we'll use this acceleration in next time step

                    next.accelerations.linear = (next_wrench.force / body.getMass()) + body.getEnvironment().getState().gravity;
                }


                if (body.isGrounded()) {
                    // this stops vehicle from vibrating while it is on the ground doing nothing.
                    next.accelerations.angular = Vector3r::Zero();
                    next.twist.linear = Vector3r::Zero();
                    next.twist.angular = Vector3r::Zero();
                }
                else {
                    //get new angular acceleration
                    //Euler's rotation equation: https://en.wikipedia.org/wiki/Euler's_equations_(body_dynamics)
                    //we will use torque to find out the angular acceleration
                    //angular momentum L = I * omega
                    const Vector3r angular_momentum = body.getInertia() * avg_angular;
                    const Vector3r angular_momentum_rate = next_wrench.torque - avg_angular.cross(angular_momentum);
                    //new angular acceleration - we'll use this acceleration in next time step
                    next.accelerations.angular = body.getInertiaInv() * angular_momentum_rate;

                    /************************* Update pose and twist after dt ************************/
                    //Verlet integration: http://www.physics.udel.edu/~bnikolic/teaching/phys660/numerical_ode/node5.html
                    next.twist.linear = current.twist.linear + (current.accelerations.linear + next.accelerations.linear) * (0.5f * dt_real);
                    next.twist.angular = current.twist.angular + (current.accelerations.angular + next.accelerations.angular) * (0.5f * dt_real);

                    //if controller has bug, velocities can increase idenfinitely 
                    //so we need to clip this or everything will turn in to infinity/nans

                    if (next.twist.linear.squaredNorm() > EarthUtils::SpeedOfLight * EarthUtils::SpeedOfLight) { //speed of light
                        next.twist.linear /= (next.twist.linear.norm() / EarthUtils::SpeedOfLight);
                        next.accelerations.linear = Vector3r::Zero();
                    }
                    //
                    //for disc of 1m radius which angular velocity translates to speed of light on tangent?
                    if (next.twist.angular.squaredNorm() > EarthUtils::SpeedOfLight * EarthUtils::SpeedOfLight) { //speed of light
                        next.twist.angular /= (next.twist.angular.norm() / EarthUtils::SpeedOfLight);
                        next.accelerations.angular = Vector3r::Zero();
                    }
                }

                computeNextPose(dt, current, next);

                //Utils::log(Utils::stringf("N-VEL %s %f: ", VectorMath::toString(next.twist.linear).c_str(), dt));
                //Utils::log(Utils::stringf("N-POS %s %f: ", VectorMath::toString(next.pose.position).c_str(), dt));

            }

            void computeNextPose(TTimeDelta dt, const Kinematics::State& current, Kinematics::State& next)
            {
                real_T dt_real = static_cast<real_T>(dt);

                if (!use_quat)
                {
                    real_T p_var = current.twist.angular(0);
                    real_T q_var = current.twist.angular(1);
                    real_T r_var = current.twist.angular(2);
                    real_T p_dot_var = current.accelerations.angular(0);
                    real_T q_dot_var = current.accelerations.angular(1);
                    real_T r_dot_var = current.accelerations.angular(2);

                    real_T theta, phi, psi;
                    VectorMath::toEulerianAngle(current.pose.orientation, theta, phi, psi);

                    // Corrected current angular velocity
                    real_T phi_update_v = p_var + tan(theta) * (q_var * sin(phi) + r_var * cos(phi));
                    real_T theta_update_v = q_var * cos(phi) - r_var * sin(phi);
                    real_T psi_update_v = (q_var * sin(phi) + r_var * cos(phi)) / cos(theta);

                    // Corrected current angular acceleration
                    real_T phi_update_a = p_dot_var + tan(theta) * (q_dot_var * sin(phi) + r_dot_var * cos(phi));
                    real_T theta_update_a = q_dot_var * cos(phi) - r_dot_var * sin(phi);
                    real_T psi_update_a = (q_dot_var * sin(phi) + r_dot_var * cos(phi)) / cos(theta);

                    real_T phi_update;
                    real_T theta_update;
                    real_T psi_update;

                    if (integration_method_x == 0)   // Verlet algorithm
                    {
                        next.pose.position = current.pose.position + current.twist.linear * dt_real + 1 / 2.0f * current.accelerations.linear * dt_real * dt_real;
                        phi_update = phi + phi_update_v * dt_real + 1 / 2.0f * phi_update_a * dt_real * dt_real;
                        theta_update = theta + theta_update_v * dt_real + 1 / 2.0f * theta_update_a * dt_real * dt_real;
                        psi_update = psi + psi_update_v * dt_real + 1 / 2.0f * psi_update_a * dt_real * dt_real;
                    }
                    else if (integration_method_x == 1)  // Verlet algorithm AirSim
                    {
                        next.pose.position = current.pose.position + current.twist.linear * dt_real;
                        phi_update = phi + phi_update_v * dt_real;
                        theta_update = theta + theta_update_v * dt_real;
                        psi_update = psi + psi_update_v * dt_real;
                    }
                    else if (integration_method_x == 2)  // Adams-Bashfort 2-step method
                    {
                        next.pose.position = current.pose.position + 3 / 2.0f * next.twist.linear * dt_real - 1 / 2.0f * current.twist.linear * dt_real;

                        real_T p_var_next = next.twist.angular(0);
                        real_T q_var_next = next.twist.angular(1);
                        real_T r_var_next = next.twist.angular(2);

                        // Corrected next angular velocity (incorrect since it uses the current angle)
                        real_T phi_update_v_next = p_var_next + tan(theta) * (q_var_next * sin(phi) + r_var_next * cos(phi));
                        real_T theta_update_v_next = q_var_next * cos(phi) - r_var_next * sin(phi);
                        real_T psi_update_v_next = (q_var_next * sin(phi) + r_var_next * cos(phi)) / cos(theta);

                        phi_update = phi + 3 / 2.0f * phi_update_v_next * dt_real - 1 / 2.0f * phi_update_v * dt_real;
                        theta_update = theta + 3 / 2.0f * theta_update_v_next * dt_real - 1 / 2.0f * theta_update_v * dt_real;
                        psi_update = psi + 3 / 2.0f * psi_update_v_next * dt_real - 1 / 2.0f * psi_update_v * dt_real;
                    }
                    else if (integration_method_x == 3)  // Beeman and Schofield
                    {
                        next.pose.position = current.pose.position + current.twist.linear * dt_real + 1 / 6.0f * (4. * current.accelerations.linear - previous.accelerations.linear) * dt_real * dt_real;

                        real_T p_var_a_previous = previous.accelerations.angular(0);
                        real_T q_var_a_previous = previous.accelerations.angular(1);
                        real_T r_var_a_previous = previous.accelerations.angular(2);

                        real_T theta_previous, phi_previous, psi_previous;
                        VectorMath::toEulerianAngle(previous.pose.orientation, theta_previous, phi_previous, psi_previous);

                        // Corrected previous angular velocity
                        real_T phi_update_a_previous = p_var_a_previous + tan(theta_previous) * (q_var_a_previous * sin(phi_previous) + r_var_a_previous * cos(phi_previous));
                        real_T theta_update_a_previous = q_var_a_previous * cos(phi_previous) - r_var_a_previous * sin(phi_previous);
                        real_T psi_update_a_previous = (q_var_a_previous * sin(phi_previous) + r_var_a_previous * cos(phi_previous)) / cos(theta_previous);

                        phi_update = phi + phi_update_v * dt_real + 1 / 6.0f * (4. * phi_update_a - phi_update_a_previous) * dt_real * dt_real;
                        theta_update = theta + theta_update_v * dt_real + 1 / 6.0f * (4. * theta_update_a - theta_update_a_previous) * dt_real * dt_real;
                        psi_update = psi + psi_update_v * dt_real + 1 / 6.0f * (4. * psi_update_a - psi_update_a_previous) * dt_real * dt_real;
                    }

                    next.pose.orientation = VectorMath::toQuaternion(theta_update, phi_update, psi_update);
                    if (VectorMath::hasNan(next.pose.orientation)) {
                        //Utils::DebugBreak();
                        Utils::log("orientation had NaN!", Utils::kLogLevelError);
                    }

                    //re-normalize quaternion to avoid accumulating error
                    next.pose.orientation.normalize();
                }
                else
                {
                    //use angular velocty in body frame to calculate angular displacement in last dt seconds
                    real_T angle_per_unit = current.twist.angular.norm();
                    next.pose.orientation = current.pose.orientation;
                    if (integration_method_x == 0)   // Verlet algorithm
                    {
                        next.pose.position = current.pose.position + current.twist.linear * dt_real + 1 / 2.0f * current.accelerations.linear * dt_real * dt_real;
                        if (Utils::isDefinitelyGreaterThan(angle_per_unit, 0.0f))
                        {
                            //convert change in angle to unit quaternion
                            AngleAxisr angle_dt_aa_1 = AngleAxisr(angle_per_unit * dt_real, current.twist.angular / angle_per_unit);
                            Quaternionr angle_dt_q_1 = Quaternionr(angle_dt_aa_1);
                            next.pose.orientation *= angle_dt_q_1;
                        }

                        real_T angle_per_unit_current_acc = current.accelerations.angular.norm();
                        if (Utils::isDefinitelyGreaterThan(angle_per_unit_current_acc, 0.0f))
                        {
                            AngleAxisr angle_dt_aa_2 = AngleAxisr(0.5f * angle_per_unit_current_acc * dt_real * dt_real, current.accelerations.angular / angle_per_unit_current_acc);
                            Quaternionr angle_dt_q_2 = Quaternionr(angle_dt_aa_2);
                            next.pose.orientation *= angle_dt_q_2;
                        }                            
                    }
                    else if (integration_method_x == 1)  // Verlet algorithm AirSim
                    {
                        next.pose.position = current.pose.position + current.twist.linear * dt_real;
                        if (Utils::isDefinitelyGreaterThan(angle_per_unit, 0.0f))
                        {
                            //convert change in angle to unit quaternion
                            AngleAxisr angle_dt_aa = AngleAxisr(angle_per_unit * dt_real, current.twist.angular / angle_per_unit);
                            Quaternionr angle_dt_q = Quaternionr(angle_dt_aa);
                            /*
                            Add change in angle to previous orientation.
                            Proof that this is q0 * q1:
                            If rotated vector is qx*v*qx' then qx is attitude
                            Initially we have q0*v*q0'
                            Lets transform this to body coordinates to get
                            q0'*(q0*v*q0')*q0
                            Then apply q1 rotation on it to get
                            q1(q0'*(q0*v*q0')*q0)q1'
                            Then transform back to world coordinate
                            q0(q1(q0'*(q0*v*q0')*q0)q1')q0'
                            which simplifies to
                            q0(q1(v)q1')q0'
                            Thus new attitude is q0q1
                            */
                            next.pose.orientation *= angle_dt_q;
                        }
                    }
                    else  if (integration_method_x == 2)  // Adams-Bashfort 2-step method
                    {
                        next.pose.position = current.pose.position + 3 / 2.0f * next.twist.linear * dt_real - 1 / 2.0f * current.twist.linear * dt_real;
                        if (Utils::isDefinitelyGreaterThan(angle_per_unit, 0.0f))
                        {
                            //convert change in angle to unit quaternion
                            AngleAxisr angle_dt_aa_1 = AngleAxisr(-1 / 2.0f * angle_per_unit * dt_real, current.twist.angular / angle_per_unit);
                            Quaternionr angle_dt_q_1 = Quaternionr(angle_dt_aa_1);
                            next.pose.orientation *= angle_dt_q_1;
                        }

                        real_T angle_per_unit_next_v = next.twist.angular.norm();
                        if (Utils::isDefinitelyGreaterThan(angle_per_unit_next_v, 0.0f))
                        {
                            AngleAxisr angle_dt_aa_2 = AngleAxisr(3 / 2.0f * angle_per_unit_next_v * dt_real, next.twist.angular / angle_per_unit_next_v);
                            Quaternionr angle_dt_q_2 = Quaternionr(angle_dt_aa_2);
                            next.pose.orientation *= angle_dt_q_2;
                        }
                    }
                    else  if (integration_method_x == 3)  // Beeman and Schofield
                    {
                        next.pose.position = current.pose.position + current.twist.linear * dt_real + 1 / 6.0f * (4. * current.accelerations.linear - previous.accelerations.linear) * dt_real * dt_real;
                        if (Utils::isDefinitelyGreaterThan(angle_per_unit, 0.0f))
                        {
                            //convert change in angle to unit quaternion
                            AngleAxisr angle_dt_aa_1 = AngleAxisr(angle_per_unit * dt_real, current.twist.angular / angle_per_unit);
                            Quaternionr angle_dt_q_1 = Quaternionr(angle_dt_aa_1);
                            next.pose.orientation *= angle_dt_q_1;
                        }

                        real_T angle_per_unit_current_acc = current.accelerations.angular.norm();
                        if (Utils::isDefinitelyGreaterThan(angle_per_unit_current_acc, 0.0f))
                        {
                            AngleAxisr angle_dt_aa_2 = AngleAxisr(4 / 6.0f * angle_per_unit_current_acc * dt_real * dt_real, current.accelerations.angular / angle_per_unit_current_acc);
                            Quaternionr angle_dt_q_2 = Quaternionr(angle_dt_aa_2);
                            next.pose.orientation *= angle_dt_q_2;
                        }

                        real_T angle_per_unit_previous_acc = previous.accelerations.angular.norm();
                        if (Utils::isDefinitelyGreaterThan(angle_per_unit_previous_acc, 0.0f))
                        {
                            AngleAxisr angle_dt_aa_3 = AngleAxisr(-1 / 6.0f * angle_per_unit_previous_acc * dt_real * dt_real, previous.accelerations.angular / angle_per_unit_previous_acc);
                            Quaternionr angle_dt_q_3 = Quaternionr(angle_dt_aa_3);
                            next.pose.orientation *= angle_dt_q_3;
                        }
                    }
                    if (VectorMath::hasNan(next.pose.orientation)) {
                        //Utils::DebugBreak();
                        Utils::log("orientation had NaN!", Utils::kLogLevelError);
                    }
                    //re-normalize quaternion to avoid accumulating error
                    next.pose.orientation.normalize();
                }                 
            }

        private:
            static constexpr uint kCollisionResponseCycles = 1;
            static constexpr float kAxisTolerance = 0.25f;
            static constexpr float kRestingVelocityMax = 0.1f;
            static constexpr float kDragMinVelocity = 0.1f;

            std::stringstream debug_string_;
            bool enable_ground_lock_;
            TTimePoint last_message_time;
            Vector3r wind_;
            float propeller_damage_coefficients[4] = { 1.0, 1.0, 1.0, 1.0 };

            // Variables for the different explicit integration methods
            bool use_average_values = false;
            bool use_quat = false;
            int integration_method_v = 1; // 0 (Verlet), 1 (AirSim), 2 (Adams-Bashfort), 3 (Beeman and Schofield)
            int integration_method_x = 1; // 0 (Verlet), 1 (AirSim), 2 (Adams-Bashfort), 3 (Beeman and Schofield)
            Kinematics::State previous;
            TTimeDelta initial_time = -1;


            // Parameter for the Bebop2
            static constexpr int max_w = 1200; // maximum number of radians per second of the propeller
            static constexpr int max_w_squared = max_w * max_w; // maximum number of radians per second of the propeller squared
            static constexpr real_T R = 0.075; // radius described by the propeller
            static constexpr real_T l = 0.0875; // distance of propeller to the y-axis of the drone
            static constexpr real_T b = 0.1150; // distance of propeller to x-axis
            static constexpr int signr = -1;
            static constexpr real_T rho = 1.225;  // density at the altitude in which the drone flies
            static constexpr int h = 5;   // variable used in the computation of dCt and dCq

            static constexpr real_T rad2deg_factor = 180.0f / M_PIf;   // variable that is used to convert an angle from radians to degrees

            real_T omega1_last = 0.0f;
            real_T omega2_last = 0.0f;
            real_T omega3_last = 0.0f;
            real_T omega4_last = 0.0f;

            FirstOrderFilter<real_T> control_signal_filter_w1;
            //FirstOrderFilter<real_T> control_signal_filter_w2;
            //FirstOrderFilter<real_T> control_signal_filter_w3;
            //FirstOrderFilter<real_T> control_signal_filter_w4;


            // Variables related to process noise
            std::default_random_engine generator;
            bool activate_process_noise = false;
            Vector3r cov_pqr = Vector3r(0.0001, 0.0001, 0.0001);
            Vector3r cov_att = Vector3r(10e-10, 10e-10, 10e-10);
            Vector3r cov_xyz = Vector3r(10e-10, 10e-10, 10e-10);
            Vector3r cov_vxyz = Vector3r(0.0001, 0.0001, 0.0001);

            Vector3r mean_pqr = Vector3r(0.0f, 0.0f, 0.0f);
            Vector3r mean_att = Vector3r(0.0f, 0.0f, 0.0f);
            Vector3r mean_xyz = Vector3r(0.0f, 0.0f, 0.0f);
            Vector3r mean_vxyz = Vector3r(0.0f, 0.0f, 0.0f);
        };

    }
} //namespace
#endif
