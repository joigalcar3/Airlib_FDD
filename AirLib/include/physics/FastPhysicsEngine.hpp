// Copyright (c) Microsoft Corporation. All rights reserved.
// Licensed under the MIT License.

#ifndef airsim_core_FastPhysicsEngine_hpp
#define airsim_core_FastPhysicsEngine_hpp

#include "common/FirstOrderFilter.hpp"

#include "common/Common.hpp"
#include "physics/PhysicsEngineBase.hpp"
#include <iostream>
#include <sstream>
#include <fstream>
#include <memory>
#include "common/CommonStructs.hpp"
#include "common/SteppableClock.hpp"
#include <cinttypes>
#include <vector>
#include <cfloat>
#include <math.h>

namespace msr {
    namespace airlib {

        class FastPhysicsEngine : public PhysicsEngineBase {
        public:
            FastPhysicsEngine(bool enable_ground_lock = true, Vector3r wind = Vector3r::Zero())
                : enable_ground_lock_(enable_ground_lock), wind_(wind)
            {
                real_T control_signal_filter_tc = 0.025f;    //time constant for low pass filter
                control_signal_filter_w1.initialize(control_signal_filter_tc, 0, 0);
                control_signal_filter_w2.initialize(control_signal_filter_tc, 0, 0);
                control_signal_filter_w3.initialize(control_signal_filter_tc, 0, 0);
                control_signal_filter_w4.initialize(control_signal_filter_tc, 0, 0);

                control_signal_filter_w1.reset();
                control_signal_filter_w2.reset();
                control_signal_filter_w3.reset();
                control_signal_filter_w4.reset();

            }

            //*** Start: UpdatableState implementation ***//
            virtual void resetImplementation() override
            {
                for (PhysicsBody* body_ptr : *this) {
                    initPhysicsBody(body_ptr);
                }
            }

            virtual void insert(PhysicsBody* body_ptr) override
            {
                PhysicsEngineBase::insert(body_ptr);

                initPhysicsBody(body_ptr);
            }

            virtual void update() override
            {
                PhysicsEngineBase::update();

                for (PhysicsBody* body_ptr : *this) {
                    updatePhysics(*body_ptr);
                }
            }
            virtual void reportState(StateReporter& reporter) override
            {
                for (PhysicsBody* body_ptr : *this) {
                    reporter.writeValue("Phys", debug_string_.str());
                    reporter.writeValue("Is Grounded", body_ptr->isGrounded());
                    reporter.writeValue("Force (world)", body_ptr->getWrench().force);
                    reporter.writeValue("Torque (body)", body_ptr->getWrench().torque);
                }
                //call base
                UpdatableObject::reportState(reporter);
            }
            //*** End: UpdatableState implementation ***//

            // Set Wind, for API and Settings implementation
            void setWind(const Vector3r& wind) override
            {
                wind_ = wind;
            }

        private:
            void initPhysicsBody(PhysicsBody* body_ptr)
            {
                body_ptr->last_kinematics_time = clock()->nowNanos();
            }

            void updatePhysics(PhysicsBody& body)
            {
                TTimeDelta dt = clock()->updateSince(body.last_kinematics_time);

                body.lock();

                //get current kinematics state of the body - this state existed since last dt seconds
                const Kinematics::State& current = body.getKinematics();
                Kinematics::State next;
                Wrench next_wrench;

                //first compute the response as if there was no collision
                //this is necessary to take in to account forces and torques generated by body
                bool bebop2_kin = true;

                if (bebop2_kin)
                {
                    getNextKinematicsNoCollisionBB2(dt, body, current, next, next_wrench, wind_, propeller_damage_coefficients);
                }
                else
                {
                    getNextKinematicsNoCollision(dt, body, current, next, next_wrench, wind_, propeller_damage_coefficients);
                }

                //if there is collision, see if we need collision response
                const CollisionInfo collision_info = body.getCollisionInfo();
                CollisionResponse& collision_response = body.getCollisionResponseInfo();
                //if collision was already responded then do not respond to it until we get updated information
                if (body.isGrounded() || (collision_info.has_collided && collision_response.collision_time_stamp != collision_info.time_stamp)) {
                    bool is_collision_response = getNextKinematicsOnCollision(dt, collision_info, body,
                        current, next, next_wrench, enable_ground_lock_);
                    updateCollisionResponseInfo(collision_info, next, is_collision_response, collision_response);
                    //throttledLogOutput("*** has collision", 0.1);
                }
                //else throttledLogOutput("*** no collision", 0.1);

                //Utils::log(Utils::stringf("T-VEL %s %" PRIu64 ": ", 
                //    VectorMath::toString(next.twist.linear).c_str(), clock()->getStepCount()));

                body.setWrench(next_wrench);
                body.updateKinematics(next);
                body.unlock();
                //body.collectCameraData();


                //TODO: this is now being done in PawnSimApi::update. We need to re-think this sequence
                //with below commented out - Arducopter GPS may not work.
                //body.getEnvironment().setPosition(next.pose.position);
                //body.getEnvironment().update();

            }

            static void updateCollisionResponseInfo(const CollisionInfo& collision_info, const Kinematics::State& next,
                bool is_collision_response, CollisionResponse& collision_response)
            {
                collision_response.collision_time_stamp = collision_info.time_stamp;
                ++collision_response.collision_count_raw;

                //increment counter if we didn't collided with high velocity (like resting on ground)
                if (is_collision_response && next.twist.linear.squaredNorm() > kRestingVelocityMax * kRestingVelocityMax)
                    ++collision_response.collision_count_non_resting;

            }

            //return value indicates if collision response was generated
            static bool getNextKinematicsOnCollision(TTimeDelta dt, const CollisionInfo& collision_info, PhysicsBody& body,
                const Kinematics::State& current, Kinematics::State& next, Wrench& next_wrench, bool enable_ground_lock)
            {
                /************************* Collision response ************************/
                const real_T dt_real = static_cast<real_T>(dt);

                //are we going away from collision? if so then keep using computed next state
                if (collision_info.normal.dot(next.twist.linear) >= 0.0f)
                    return false;

                /********** Core collision response ***********/
                //get avg current velocity
                const Vector3r vcur_avg = current.twist.linear + current.accelerations.linear * dt_real;

                //get average angular velocity
                const Vector3r angular_avg = current.twist.angular + current.accelerations.angular * dt_real;

                //contact point vector
                Vector3r r = collision_info.impact_point - collision_info.position;

                //see if impact is straight at body's surface (assuming its box)
                const Vector3r normal_body = VectorMath::transformToBodyFrame(collision_info.normal, current.pose.orientation);
                const bool is_ground_normal = Utils::isApproximatelyEqual(std::abs(normal_body.z()), 1.0f, kAxisTolerance);
                bool ground_collision = false;
                const float z_vel = vcur_avg.z();
                const bool is_landing = z_vel > std::abs(vcur_avg.x()) && z_vel > std::abs(vcur_avg.y());

                real_T restitution = body.getRestitution();
                real_T friction = body.getFriction();

                if (is_ground_normal && is_landing
                    // So normal_body is the collision normal translated into body coords, why does an x==1 or y==1
                    // mean we are coliding with the ground???
                    // || Utils::isApproximatelyEqual(std::abs(normal_body.x()), 1.0f, kAxisTolerance) 
                    // || Utils::isApproximatelyEqual(std::abs(normal_body.y()), 1.0f, kAxisTolerance) 
                    ) {
                    // looks like we are coliding with the ground.  We don't want the ground to be so bouncy
                    // so we reduce the coefficient of restitution.  0 means no bounce.
                    // TODO: it would be better if we did this based on the material we are landing on.
                    // e.g. grass should be inelastic, but a hard surface like the road should be more bouncy.
                    restitution = 0;
                    // crank up friction with the ground so it doesn't try and slide across the ground
                    // again, this should depend on the type of surface we are landing on.
                    friction = 1;

                    //we have collided with ground straight on, we will fix orientation later
                    ground_collision = is_ground_normal;
                }

                //velocity at contact point
                const Vector3r vcur_avg_body = VectorMath::transformToBodyFrame(vcur_avg, current.pose.orientation);
                const Vector3r contact_vel_body = vcur_avg_body + angular_avg.cross(r);

                /*
                    GafferOnGames - Collision response with columb friction
                    http://gafferongames.com/virtual-go/collision-response-and-coulomb-friction/
                    Assuming collision is with static fixed body,
                    impulse magnitude = j = -(1 + R)V.N / (1/m + (I'(r X N) X r).N)
                    Physics Part 3, Collision Response, Chris Hecker, eq 4(a)
                    http://chrishecker.com/images/e/e7/Gdmphys3.pdf
                    V(t+1) = V(t) + j*N / m
                */
                const real_T impulse_mag_denom = 1.0f / body.getMass() +
                    (body.getInertiaInv() * r.cross(normal_body))
                    .cross(r)
                    .dot(normal_body);
                const real_T impulse_mag = -contact_vel_body.dot(normal_body) * (1 + restitution) / impulse_mag_denom;

                next.twist.linear = vcur_avg + collision_info.normal * (impulse_mag / body.getMass());
                next.twist.angular = angular_avg + r.cross(normal_body) * impulse_mag;

                //above would modify component in direction of normal
                //we will use friction to modify component in direction of tangent
                const Vector3r contact_tang_body = contact_vel_body - normal_body * normal_body.dot(contact_vel_body);
                const Vector3r contact_tang_unit_body = contact_tang_body.normalized();
                const real_T friction_mag_denom = 1.0f / body.getMass() +
                    (body.getInertiaInv() * r.cross(contact_tang_unit_body))
                    .cross(r)
                    .dot(contact_tang_unit_body);
                const real_T friction_mag = -contact_tang_body.norm() * friction / friction_mag_denom;

                const Vector3r contact_tang_unit = VectorMath::transformToWorldFrame(contact_tang_unit_body, current.pose.orientation);
                next.twist.linear += contact_tang_unit * friction_mag;
                next.twist.angular += r.cross(contact_tang_unit_body) * (friction_mag / body.getMass());

                //TODO: implement better rolling friction
                next.twist.angular *= 0.9f;

                // there is no acceleration during collision response, this is a hack, but without it the acceleration cancels
                // the computed impulse response too much and stops the vehicle from bouncing off the collided object.
                next.accelerations.linear = Vector3r::Zero();
                next.accelerations.angular = Vector3r::Zero();

                next.pose = current.pose;
                if (enable_ground_lock && ground_collision) {
                    float pitch, roll, yaw;
                    VectorMath::toEulerianAngle(next.pose.orientation, pitch, roll, yaw);
                    pitch = roll = 0;
                    next.pose.orientation = VectorMath::toQuaternion(pitch, roll, yaw);

                    //there is a lot of random angular velocity when vehicle is on the ground
                    next.twist.angular = Vector3r::Zero();

                    // also eliminate any linear velocity due to twist - since we are sitting on the ground there shouldn't be any.
                    next.twist.linear = Vector3r::Zero();
                    next.pose.position = collision_info.position;
                    body.setGrounded(true);

                    // but we do want to "feel" the ground when we hit it (we should see a small z-acc bump)
                    // equal and opposite our downward velocity.
                    next.accelerations.linear = -0.5f * body.getMass() * vcur_avg;

                    //throttledLogOutput("*** Triggering ground lock", 0.1);
                }
                else
                {
                    //else keep the orientation
                    next.pose.position = collision_info.position + (collision_info.normal * collision_info.penetration_depth) + next.twist.linear * (dt_real * kCollisionResponseCycles);
                }
                next_wrench = Wrench::zero();

                //Utils::log(Utils::stringf("*** C-VEL %s: ", VectorMath::toString(next.twist.linear).c_str()));

                return true;
            }

            void throttledLogOutput(const std::string& msg, double seconds)
            {
                TTimeDelta dt = clock()->elapsedSince(last_message_time);
                const real_T dt_real = static_cast<real_T>(dt);
                if (dt_real > seconds)
                {
                    Utils::log(msg);
                    last_message_time = clock()->nowNanos();
                }
            }

            static Wrench getDragWrench(const PhysicsBody& body, const Quaternionr& orientation,
                const Vector3r& linear_vel, const Vector3r& angular_vel_body, const Vector3r& wind_world)
            {
                //add linear drag due to velocity we had since last dt seconds + wind
                //drag vector magnitude is proportional to v^2, direction opposite of velocity
                //total drag is b*v + c*v*v but we ignore the first term as b << c (pg 44, Classical Mechanics, John Taylor)
                //To find the drag force, we find the magnitude in the body frame and unit vector direction in world frame
                //http://physics.stackexchange.com/questions/304742/angular-drag-on-body
                //similarly calculate angular drag
                //note that angular velocity, acceleration, torque are already in body frame

                Wrench wrench = Wrench::zero();
                const real_T air_density = body.getEnvironment().getState().air_density;

                // Use relative velocity of the body wrt wind
                const Vector3r relative_vel = linear_vel - wind_world;
                const Vector3r linear_vel_body = VectorMath::transformToBodyFrame(relative_vel, orientation);

                for (uint vi = 0; vi < body.dragVertexCount(); ++vi) {
                    const auto& vertex = body.getDragVertex(vi);
                    const Vector3r vel_vertex = linear_vel_body + angular_vel_body.cross(vertex.getPosition());
                    const real_T vel_comp = vertex.getNormal().dot(vel_vertex);
                    //if vel_comp is -ve then we cull the face. If velocity too low then drag is not generated
                    if (vel_comp > kDragMinVelocity) {
                        const Vector3r drag_force = vertex.getNormal() * (-vertex.getDragFactor() * air_density * vel_comp * vel_comp);
                        const Vector3r drag_torque = vertex.getPosition().cross(drag_force);

                        wrench.force += drag_force;
                        wrench.torque += drag_torque;
                    }
                }

                //convert force to world frame, leave torque to local frame
                wrench.force = VectorMath::transformToWorldFrame(wrench.force, orientation);

                return wrench;
            }

            static Wrench getBodyWrench(const PhysicsBody& body, const Quaternionr& orientation, float prop_damage[])
            {
                //set wrench sum to zero
                Wrench wrench = Wrench::zero();
                //calculate total force on rigid body's center of gravity
                for (uint i = 0; i < body.wrenchVertexCount(); ++i) {
                    //aggregate total
                    std::cout << prop_damage[i] << std::endl;
                    const PhysicsBodyVertex& vertex = body.getWrenchVertex(i);
                    const auto& vertex_wrench = vertex.getWrench();
                    const auto damage_coeff = prop_damage[i];
                    Vector3r local_force = Vector3r(vertex_wrench.force.x() * damage_coeff, vertex_wrench.force.y() * damage_coeff, vertex_wrench.force.z() * damage_coeff);
                    Vector3r local_torque = Vector3r(vertex_wrench.torque.x() * damage_coeff, vertex_wrench.torque.y() * damage_coeff, vertex_wrench.torque.z() * damage_coeff);
                    Wrench local_wrench = Wrench::zero();
                    local_wrench.force = local_force;
                    local_wrench.torque = local_torque;
                    wrench += local_wrench;

                    //const auto& vertex_wrench = vertex.getWrench();
                    //wrench += vertex_wrench;

                    //add additional torque due to force applies farther than COG
                    // tau = r X F
                    Wrench wrench_cross = Wrench::zero();
                    wrench_cross.torque = vertex.getPosition().cross(vertex_wrench.force);
                    Vector3r cross_torque = Vector3r(wrench_cross.torque.x() * damage_coeff, wrench_cross.torque.y() * damage_coeff, wrench_cross.torque.z() * damage_coeff);
                    wrench.torque += cross_torque;
                    //wrench.torque += vertex.getPosition().cross(vertex_wrench.force);
                }

                //convert force to world frame, leave torque to local frame
                wrench.force = VectorMath::transformToWorldFrame(wrench.force, orientation);

                return wrench;
            }

            static int findNearestNeighbourIndex(float value, std::vector<float>& x)
            {
                float dist = FLT_MAX;
                int idx = -1;
                for (int i = 0; i < x.size(); ++i) {
                    float newDist = value - x[i];
                    if (newDist > 0 && newDist < dist) {
                        dist = newDist;
                        idx = i;
                    }
                }

                return idx;
            }

            static float interp1(std::vector<float>& x, std::vector<float>& y, float x_new)
            {
                float y_new;

                std::vector<float> dx, dy, slope, intercept;
                dx.reserve(x.size());
                dy.reserve(x.size());
                slope.reserve(x.size());
                intercept.reserve(x.size());
                for (int i = 0; i < x.size(); ++i) {
                    if (i < x.size() - 1)
                    {
                        dx.push_back(x[i + 1] - x[i]);
                        dy.push_back(y[i + 1] - y[i]);
                        slope.push_back(dy[i] / dx[i]);
                        intercept.push_back(y[i] - x[i] * slope[i]);
                    }
                    else
                    {
                        dx.push_back(dx[i - 1]);
                        dy.push_back(dy[i - 1]);
                        slope.push_back(slope[i - 1]);
                        intercept.push_back(intercept[i - 1]);
                    }
                }
                if (x_new <= x[0])
                {
                    y_new = slope[0] * x_new + intercept[0];
                }
                else
                {
                    int idx = findNearestNeighbourIndex(x_new, x);
                    y_new = slope[idx] * x_new + intercept[idx];
                }
                return y_new;
            }

            static inline double computeSquare(double x)
            {
                return x * x;
            }

            static inline double computeCube(double x)
            {
                return x * x * x;
            }

            static inline double computeQuartic(double x)
            {
                return x * x * x * x;
            }

            static inline double computeQuintic(double x)
            {
                return x * x * x * x * x;
            }

            // Function that creates a 3rd degree polynomial with 3 parameters
            static std::vector<real_T> P33(std::vector<real_T> x1, std::vector<real_T> x2, std::vector<real_T> x3 = std::vector<real_T>(), std::vector<real_T> U = std::vector<real_T>())
            {
                if (x3.size() == 0)
                {
                    for (int i = 0; i < x1.size(); i++)
                    {
                        x3.push_back(1);
                    }
                }
                if (U.size() == 0)
                {
                    for (int i = 0; i < x1.size(); i++)
                    {
                        U.push_back(1);
                    }
                }
                std::vector<real_T> initial(x1.size(), 1);
                std::vector<real_T> x12;
                std::vector<real_T> x13;
                std::vector<real_T> x22;
                std::vector<real_T> x23;
                std::vector<real_T> x32;
                std::vector<real_T> x33;

                std::vector<real_T> x1_x2;
                std::vector<real_T> x2_x3;
                std::vector<real_T> x3_x1;

                std::vector<real_T> x1_x22;
                std::vector<real_T> x1_x32;
                std::vector<real_T> x12_x2;
                std::vector<real_T> x12_x3;
                std::vector<real_T> x22_x3;
                std::vector<real_T> x2_x32;
                std::vector<real_T> x1_x2_x3;


                std::transform(x1.begin(), x1.end(), std::back_inserter(x12), computeSquare);
                std::transform(x1.begin(), x1.end(), std::back_inserter(x13), computeCube);
                std::transform(x2.begin(), x2.end(), std::back_inserter(x22), computeSquare);
                std::transform(x2.begin(), x2.end(), std::back_inserter(x23), computeCube);
                std::transform(x3.begin(), x3.end(), std::back_inserter(x32), computeSquare);
                std::transform(x3.begin(), x3.end(), std::back_inserter(x33), computeCube);

                std::transform(x1.begin(), x1.end(), x2.begin(), std::back_inserter(x1_x2), std::multiplies<real_T>());
                std::transform(x2.begin(), x2.end(), x3.begin(), std::back_inserter(x2_x3), std::multiplies<real_T>());
                std::transform(x3.begin(), x3.end(), x1.begin(), std::back_inserter(x3_x1), std::multiplies<real_T>());

                std::transform(x1.begin(), x1.end(), x22.begin(), std::back_inserter(x1_x22), std::multiplies<real_T>());
                std::transform(x1.begin(), x1.end(), x32.begin(), std::back_inserter(x1_x32), std::multiplies<real_T>());
                std::transform(x12.begin(), x12.end(), x2.begin(), std::back_inserter(x12_x2), std::multiplies<real_T>());
                std::transform(x12.begin(), x12.end(), x3.begin(), std::back_inserter(x12_x3), std::multiplies<real_T>());
                std::transform(x22.begin(), x22.end(), x3.begin(), std::back_inserter(x22_x3), std::multiplies<real_T>());
                std::transform(x2.begin(), x2.end(), x32.begin(), std::back_inserter(x2_x32), std::multiplies<real_T>());
                std::transform(x1_x2.begin(), x1_x2.end(), x3.begin(), std::back_inserter(x1_x2_x3), std::multiplies<real_T>());


                std::vector<real_T> A1;
                std::transform(initial.begin(), initial.end(), U.begin(), std::back_inserter(A1), std::multiplies<real_T>());
                std::vector<real_T> A2;
                std::transform(x1.begin(), x1.end(), U.begin(), std::back_inserter(A2), std::multiplies<real_T>());
                std::vector<real_T> A3;
                std::transform(x2.begin(), x2.end(), U.begin(), std::back_inserter(A3), std::multiplies<real_T>());
                std::vector<real_T> A4;
                std::transform(x3.begin(), x3.end(), U.begin(), std::back_inserter(A4), std::multiplies<real_T>());
                std::vector<real_T> A5;
                std::transform(x12.begin(), x12.end(), U.begin(), std::back_inserter(A5), std::multiplies<real_T>());
                std::vector<real_T> A6;
                std::transform(x22.begin(), x22.end(), U.begin(), std::back_inserter(A6), std::multiplies<real_T>());
                std::vector<real_T> A7;
                std::transform(x32.begin(), x32.end(), U.begin(), std::back_inserter(A7), std::multiplies<real_T>());
                std::vector<real_T> A8;
                std::transform(x1_x2.begin(), x1_x2.end(), U.begin(), std::back_inserter(A8), std::multiplies<real_T>());
                std::vector<real_T> A9;
                std::transform(x2_x3.begin(), x2_x3.end(), U.begin(), std::back_inserter(A9), std::multiplies<real_T>());
                std::vector<real_T> A10;
                std::transform(x3_x1.begin(), x3_x1.end(), U.begin(), std::back_inserter(A10), std::multiplies<real_T>());
                std::vector<real_T> A11;
                std::transform(x13.begin(), x13.end(), U.begin(), std::back_inserter(A11), std::multiplies<real_T>());
                std::vector<real_T> A12;
                std::transform(x23.begin(), x23.end(), U.begin(), std::back_inserter(A12), std::multiplies<real_T>());
                std::vector<real_T> A13;
                std::transform(x33.begin(), x33.end(), U.begin(), std::back_inserter(A13), std::multiplies<real_T>());
                std::vector<real_T> A14;
                std::transform(x1_x22.begin(), x1_x22.end(), U.begin(), std::back_inserter(A14), std::multiplies<real_T>());
                std::vector<real_T> A15;
                std::transform(x1_x32.begin(), x1_x32.end(), U.begin(), std::back_inserter(A15), std::multiplies<real_T>());
                std::vector<real_T> A16;
                std::transform(x12_x2.begin(), x12_x2.end(), U.begin(), std::back_inserter(A16), std::multiplies<real_T>());
                std::vector<real_T> A17;
                std::transform(x12_x3.begin(), x12_x3.end(), U.begin(), std::back_inserter(A17), std::multiplies<real_T>());
                std::vector<real_T> A18;
                std::transform(x22_x3.begin(), x22_x3.end(), U.begin(), std::back_inserter(A18), std::multiplies<real_T>());
                std::vector<real_T> A19;
                std::transform(x2_x32.begin(), x2_x32.end(), U.begin(), std::back_inserter(A19), std::multiplies<real_T>());
                std::vector<real_T> A20;
                std::transform(x1_x2_x3.begin(), x1_x2_x3.end(), U.begin(), std::back_inserter(A20), std::multiplies<real_T>());

                std::vector<std::vector<real_T>> vector_of_vectors = { A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12, A13, A14, A15, A16, A17, A18, A19, A20 };
                std::vector<real_T> P33_output;
                for (int i = 0; i < vector_of_vectors.size(); i++)
                {
                    P33_output.insert(P33_output.end(), vector_of_vectors[i].begin(), vector_of_vectors[i].end());
                }
                return P33_output;
            }

            // Function to find the 5th degree polynomial with 2 parameters
            static std::vector<real_T> P52(std::vector<real_T> x1, std::vector<real_T> x2, std::vector<real_T> U = std::vector<real_T>())
            {
                if (U.size() == 0)
                {
                    for (int i = 0; i < x1.size(); i++)
                    {
                        U.push_back(1);
                    }
                }
                std::vector<real_T> initial(x1.size(), 1);
                std::vector<real_T> x12;
                std::vector<real_T> x13;
                std::vector<real_T> x14;
                std::vector<real_T> x15;
                std::vector<real_T> x22;
                std::vector<real_T> x23;
                std::vector<real_T> x24;
                std::vector<real_T> x25;

                std::vector<real_T> x1_x2;
                std::vector<real_T> x1_x22;
                std::vector<real_T> x1_x23;
                std::vector<real_T> x1_x24;

                std::vector<real_T> x12_x2;
                std::vector<real_T> x12_x22;
                std::vector<real_T> x12_x23;

                std::vector<real_T> x13_x2;
                std::vector<real_T> x13_x22;

                std::vector<real_T> x14_x2;

                std::transform(x1.begin(), x1.end(), std::back_inserter(x12), computeSquare);
                std::transform(x1.begin(), x1.end(), std::back_inserter(x13), computeCube);
                std::transform(x1.begin(), x1.end(), std::back_inserter(x14), computeQuartic);
                std::transform(x1.begin(), x1.end(), std::back_inserter(x15), computeQuintic);
                std::transform(x2.begin(), x2.end(), std::back_inserter(x22), computeSquare);
                std::transform(x2.begin(), x2.end(), std::back_inserter(x23), computeCube);
                std::transform(x2.begin(), x2.end(), std::back_inserter(x24), computeQuartic);
                std::transform(x2.begin(), x2.end(), std::back_inserter(x25), computeQuintic);

                std::transform(x1.begin(), x1.end(), x2.begin(), std::back_inserter(x1_x2), std::multiplies<real_T>());
                std::transform(x1.begin(), x1.end(), x22.begin(), std::back_inserter(x1_x22), std::multiplies<real_T>());
                std::transform(x1.begin(), x1.end(), x23.begin(), std::back_inserter(x1_x23), std::multiplies<real_T>());
                std::transform(x1.begin(), x1.end(), x24.begin(), std::back_inserter(x1_x24), std::multiplies<real_T>());

                std::transform(x12.begin(), x12.end(), x2.begin(), std::back_inserter(x12_x2), std::multiplies<real_T>());
                std::transform(x12.begin(), x12.end(), x22.begin(), std::back_inserter(x12_x22), std::multiplies<real_T>());
                std::transform(x12.begin(), x12.end(), x23.begin(), std::back_inserter(x12_x23), std::multiplies<real_T>());

                std::transform(x13.begin(), x13.end(), x2.begin(), std::back_inserter(x13_x2), std::multiplies<real_T>());
                std::transform(x13.begin(), x13.end(), x22.begin(), std::back_inserter(x13_x22), std::multiplies<real_T>());

                std::transform(x14.begin(), x14.end(), x2.begin(), std::back_inserter(x14_x2), std::multiplies<real_T>());

                std::vector<real_T> A1;
                std::transform(initial.begin(), initial.end(), U.begin(), std::back_inserter(A1), std::multiplies<real_T>());
                std::vector<real_T> A2;
                std::transform(x1.begin(), x1.end(), U.begin(), std::back_inserter(A2), std::multiplies<real_T>());
                std::vector<real_T> A3;
                std::transform(x2.begin(), x2.end(), U.begin(), std::back_inserter(A3), std::multiplies<real_T>());
                std::vector<real_T> A4;
                std::transform(x22.begin(), x22.end(), U.begin(), std::back_inserter(A4), std::multiplies<real_T>());
                std::vector<real_T> A5;
                std::transform(x1_x2.begin(), x1_x2.end(), U.begin(), std::back_inserter(A5), std::multiplies<real_T>());
                std::vector<real_T> A6;
                std::transform(x22.begin(), x22.end(), U.begin(), std::back_inserter(A6), std::multiplies<real_T>());
                std::vector<real_T> A7;
                std::transform(x13.begin(), x13.end(), U.begin(), std::back_inserter(A7), std::multiplies<real_T>());
                std::vector<real_T> A8;
                std::transform(x12_x2.begin(), x12_x2.end(), U.begin(), std::back_inserter(A8), std::multiplies<real_T>());
                std::vector<real_T> A9;
                std::transform(x1_x22.begin(), x1_x22.end(), U.begin(), std::back_inserter(A9), std::multiplies<real_T>());
                std::vector<real_T> A10;
                std::transform(x23.begin(), x23.end(), U.begin(), std::back_inserter(A10), std::multiplies<real_T>());
                std::vector<real_T> A11;
                std::transform(x14.begin(), x14.end(), U.begin(), std::back_inserter(A11), std::multiplies<real_T>());
                std::vector<real_T> A12;
                std::transform(x13_x2.begin(), x13_x2.end(), U.begin(), std::back_inserter(A12), std::multiplies<real_T>());
                std::vector<real_T> A13;
                std::transform(x12_x22.begin(), x12_x22.end(), U.begin(), std::back_inserter(A13), std::multiplies<real_T>());
                std::vector<real_T> A14;
                std::transform(x1_x23.begin(), x1_x23.end(), U.begin(), std::back_inserter(A14), std::multiplies<real_T>());
                std::vector<real_T> A15;
                std::transform(x24.begin(), x24.end(), U.begin(), std::back_inserter(A15), std::multiplies<real_T>());
                std::vector<real_T> A16;
                std::transform(x15.begin(), x15.end(), U.begin(), std::back_inserter(A16), std::multiplies<real_T>());
                std::vector<real_T> A17;
                std::transform(x14_x2.begin(), x14_x2.end(), U.begin(), std::back_inserter(A17), std::multiplies<real_T>());
                std::vector<real_T> A18;
                std::transform(x13_x22.begin(), x13_x22.end(), U.begin(), std::back_inserter(A18), std::multiplies<real_T>());
                std::vector<real_T> A19;
                std::transform(x12_x23.begin(), x12_x23.end(), U.begin(), std::back_inserter(A19), std::multiplies<real_T>());
                std::vector<real_T> A20;
                std::transform(x1_x24.begin(), x1_x24.end(), U.begin(), std::back_inserter(A20), std::multiplies<real_T>());
                std::vector<real_T> A21;
                std::transform(x25.begin(), x25.end(), U.begin(), std::back_inserter(A21), std::multiplies<real_T>());

                std::vector<std::vector<real_T>> vector_of_vectors = { A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12, A13, A14, A15, A16, A17, A18, A19, A20, A21 };
                std::vector<real_T> P52_output;
                for (int i = 0; i < vector_of_vectors.size(); i++)
                {
                    P52_output.insert(P52_output.end(), vector_of_vectors[i].begin(), vector_of_vectors[i].end());
                }
                return P52_output;

            }

            // regressor generator nrd order polynomial function with 1 inputs
            static std::vector<std::vector<real_T>> P1n(std::vector<real_T> x, int n = -1, real_T bias = -1, std::vector<real_T> U = std::vector<real_T>())
            {
                if (n == -1) { n = 2; }
                if (bias == -1) { bias = 1; }
                if (U.size() == 0)
                {
                    for (int i = 0; i < x.size(); i++)
                    {
                        U.push_back(1);
                    }
                }

                std::vector<std::vector<real_T>> Ap1n;
                if (bias != 0)
                {
                    std::vector<real_T> local(x.size(), 1);
                    std::vector<real_T> local2;
                    std::transform(local.begin(), local.end(), U.begin(), std::back_inserter(local2), std::multiplies<real_T>());
                    Ap1n.push_back(local2);
                }

                std::vector<real_T> exponential_term(x.size(), 1);
                Ap1n.push_back(exponential_term);
                for (int i = 1; i < n; i++)
                {
                    std::transform(exponential_term.begin(), exponential_term.end(), x.begin(), std::back_inserter(exponential_term), std::multiplies<real_T>());
                    std::vector<real_T> local;
                    std::transform(exponential_term.begin(), exponential_term.end(), U.begin(), std::back_inserter(local), std::multiplies<real_T>());
                    Ap1n.push_back(local);
                }
                return Ap1n;
            }

            // regressor generator 3rd order polynomial function with 2 inputs
            static std::vector<std::vector<real_T>> P32(std::vector<real_T> x1, std::vector<real_T> x2, std::vector<real_T> U = std::vector<real_T>(), real_T bias = -1)
            {
                if (U.size() == 0)
                {
                    for (int i = 0; i < x1.size(); i++)
                    {
                        U.push_back(1);
                    }
                }

                std::vector<real_T> x12;
                std::vector<real_T> x13;
                std::vector<real_T> x22;
                std::vector<real_T> x23;

                std::vector<real_T> x1_x2;
                std::vector<real_T> x1_x22;

                std::vector<real_T> x12_x2;

                std::transform(x1.begin(), x1.end(), std::back_inserter(x12), computeSquare);
                std::transform(x1.begin(), x1.end(), std::back_inserter(x13), computeCube);
                std::transform(x2.begin(), x2.end(), std::back_inserter(x22), computeSquare);
                std::transform(x2.begin(), x2.end(), std::back_inserter(x23), computeCube);

                std::transform(x1.begin(), x1.end(), x2.begin(), std::back_inserter(x1_x2), std::multiplies<real_T>());
                std::transform(x1.begin(), x1.end(), x22.begin(), std::back_inserter(x1_x22), std::multiplies<real_T>());

                std::transform(x12.begin(), x12.end(), x2.begin(), std::back_inserter(x12_x2), std::multiplies<real_T>());

                std::vector<real_T> A2;
                std::transform(x1.begin(), x1.end(), U.begin(), std::back_inserter(A2), std::multiplies<real_T>());
                std::vector<real_T> A3;
                std::transform(x2.begin(), x2.end(), U.begin(), std::back_inserter(A3), std::multiplies<real_T>());
                std::vector<real_T> A4;
                std::transform(x12.begin(), x12.end(), U.begin(), std::back_inserter(A4), std::multiplies<real_T>());
                std::vector<real_T> A5;
                std::transform(x22.begin(), x22.end(), U.begin(), std::back_inserter(A5), std::multiplies<real_T>());
                std::vector<real_T> A6;
                std::transform(x1_x2.begin(), x1_x2.end(), U.begin(), std::back_inserter(A6), std::multiplies<real_T>());
                std::vector<real_T> A7;
                std::transform(x13.begin(), x13.end(), U.begin(), std::back_inserter(A7), std::multiplies<real_T>());
                std::vector<real_T> A8;
                std::transform(x23.begin(), x23.end(), U.begin(), std::back_inserter(A8), std::multiplies<real_T>());
                std::vector<real_T> A9;
                std::transform(x1_x22.begin(), x1_x22.end(), U.begin(), std::back_inserter(A9), std::multiplies<real_T>());
                std::vector<real_T> A10;
                std::transform(x12_x2.begin(), x12_x2.end(), U.begin(), std::back_inserter(A10), std::multiplies<real_T>());

                std::vector<std::vector<real_T>> P32_output;
                if (bias != -1)
                {
                    std::vector<real_T> A1;
                    std::vector<real_T> initial(x1.size(), 1);
                    std::transform(initial.begin(), initial.end(), U.begin(), std::back_inserter(A1), std::multiplies<real_T>());
                    P32_output = { A1, A2, A3, A4, A5, A6, A7, A8, A9, A10 };
                }
                else
                {
                    P32_output = { A2, A3, A4, A5, A6, A7, A8, A9, A10 };
                }

                
                return P32_output;
            }

            static std::vector<real_T> sine_component_computation(std::vector<real_T> x, std::vector<real_T> U, int i)
            {
                std::vector<real_T> sine_oper;
                std::vector<real_T> sine_component;
                for (int j = 0; j < x.size(); j++)
                {
                    sine_oper.push_back(sin((i+1) * x[j]));
                }
                std::transform(sine_oper.begin(), sine_oper.end(), U.begin(), std::back_inserter(sine_component), std::multiplies<real_T>());
                return sine_component;
            }

            static std::vector<real_T> cosine_component_computation(std::vector<real_T> x, std::vector<real_T> U, int i)
            {
                std::vector<real_T> cosine_oper;
                std::vector<real_T> cosine_component;
                for (int j = 0; j < x.size(); j++)
                {
                    cosine_oper.push_back(cos((i+1) * x[j]));
                }
                std::transform(cosine_oper.begin(), cosine_oper.end(), U.begin(), std::back_inserter(cosine_component), std::multiplies<real_T>());
                return cosine_component;
            }

            static std::vector<real_T> Fn(std::vector<real_T> x, int n = -1, real_T bias = -1, std::vector<real_T> U = std::vector<real_T>(), std::vector<real_T> alpha = std::vector<real_T>(), std::vector<real_T> beta = std::vector<real_T>())
            {
                if (n == -1) { n = 1; }
                if (bias == -1) { bias = 1; }
                if (U.size() == 0)
                {
                    for (int i = 0; i < x.size(); i++)
                    {
                        U.push_back(1);
                    }
                }

                std::vector<std::vector<real_T>> A_F;
                if (bias != 0)
                {
                    std::vector<real_T> local(x.size(), 1);
                    A_F.push_back(local);
                }

                if (alpha.size() == 0)
                {
                    for (int i = 0; i < n; i++)
                    {
                        std::vector<real_T> sine_component = sine_component_computation(x, U, i);
                        std::vector<real_T> cosine_component = cosine_component_computation(x, U, i);

                        A_F.push_back(sine_component);
                        A_F.push_back(cosine_component);
                    }
                }
                else if (beta.size() == 0)
                {
                    for (int i = 0; i < n; i++)
                    {
                        std::vector<real_T> sine_component = sine_component_computation(x, U, i);
                        std::vector<std::vector<real_T>> Ai1 = P1n(alpha, 3, 1, sine_component);

                        std::vector<real_T> cosine_component = cosine_component_computation(x, U, i);
                        std::vector<std::vector<real_T>> Ai2 = P1n(alpha, 3, 1, cosine_component);

                        std::vector<real_T> Ai1_f;
                        std::vector<real_T> Ai2_f;
                        for (int j = 0; j < Ai1.size(); j++)
                        {
                            Ai1_f.push_back(Ai1[j][0]);
                            Ai2_f.push_back(Ai2[j][0]);
                        }

                        A_F.push_back(Ai1_f);
                        A_F.push_back(Ai2_f);
                    }
                }
                else
                {
                    for (int i = 0; i < n; i++)
                    {
                        std::vector<real_T> sine_component = sine_component_computation(x, U, i);
                        std::vector<std::vector<real_T>> Ai1 = P32(alpha, beta, sine_component);

                        std::vector<real_T> cosine_component = cosine_component_computation(x, U, i);
                        std::vector<std::vector<real_T>> Ai2 = P32(alpha, beta, cosine_component);

                        std::vector<real_T> Ai1_f;
                        std::vector<real_T> Ai2_f;
                        for (int j = 0; j < Ai1.size(); j++)
                        {
                            Ai1_f.push_back(Ai1[j][0]);
                            Ai2_f.push_back(Ai2[j][0]);
                        }

                        A_F.push_back(Ai1_f);
                        A_F.push_back(Ai2_f);
                    }
                }

                std::vector<real_T> A_F_f;
                for (int i = 0; i < A_F.size(); i++)
                {
                    A_F_f.insert(A_F_f.end(), A_F[i].begin(), A_F[i].end());
                }
                return A_F_f;
            }

            // Function to find
            // cross product of two vector array.
            static void crossProduct(std::vector<real_T> vect_A, std::vector<real_T> vect_B, std::vector<real_T>& cross_P)

            {

                cross_P[0] = vect_A[1] * vect_B[2] - vect_A[2] * vect_B[1];
                cross_P[1] = vect_A[2] * vect_B[0] - vect_A[0] * vect_B[2];
                cross_P[2] = vect_A[0] * vect_B[1] - vect_A[1] * vect_B[0];
            }

            //function to calculate dot product of two vectors
            static real_T dot_product(std::vector<real_T> vector_a, std::vector<real_T> vector_b) {
                real_T product = 0;
                for (int i = 0; i < vector_a.size(); i++)
                    product = product + vector_a[i] * vector_b[i];
                return product;
            }

            static real_T calc_beta2(real_T uy, real_T vx)
            {
                real_T beta = atan2(uy, vx);
                if (beta < 0)
                {
                    beta = 2 * M_PIf + beta;
                }
                beta = beta - M_PIf / 2;
                if (beta < 0)
                {
                    beta = 2 * M_PIf + beta;
                }
                return beta;
            }
            void getNextKinematicsNoCollisionBB2(TTimeDelta dt, PhysicsBody& body, const Kinematics::State& current,
                Kinematics::State& next, Wrench& next_wrench, const Vector3r& wind, float prop_damage[])
            {
                const real_T dt_real = static_cast<real_T>(dt);
                Vector3r avg_linear = Vector3r::Zero();
                Vector3r avg_angular = Vector3r::Zero();
                avg_linear = current.twist.linear + current.accelerations.linear * (0.5f * dt_real);
                avg_angular = current.twist.angular + current.accelerations.angular * (0.5f * dt_real);

                // Obtain PWM of the rotors and their rotational speeds
                std::vector<real_T> PWMs = body.getPWMrotors();
                control_signal_filter_w1.setInput(Utils::clip(PWMs[0], 0.0f, 1.0f));
                control_signal_filter_w2.setInput(Utils::clip(PWMs[1], 0.0f, 1.0f));
                control_signal_filter_w3.setInput(Utils::clip(PWMs[2], 0.0f, 1.0f));
                control_signal_filter_w4.setInput(Utils::clip(PWMs[3], 0.0f, 1.0f));
                real_T PWMs_0 = control_signal_filter_w1.getOutput();
                real_T PWMs_1 = control_signal_filter_w2.getOutput();
                real_T PWMs_2 = control_signal_filter_w3.getOutput();
                real_T PWMs_3 = control_signal_filter_w4.getOutput();

                real_T omega1 = sqrt(PWMs_0 * max_w_squared);
                real_T omega2 = sqrt(PWMs_1 * max_w_squared);
                real_T omega3 = sqrt(PWMs_2 * max_w_squared);
                real_T omega4 = sqrt(PWMs_3 * max_w_squared);

                control_signal_filter_w1.update();
                control_signal_filter_w2.update();
                control_signal_filter_w3.update();
                control_signal_filter_w4.update();

                // Circular area descibed by the rotating propeller
                real_T Area = M_PIf * R * R;

                // Velocity of the drone
                // Use relative velocity of the body wrt wind
                const Vector3r relative_vel = avg_linear - wind;
                const Vector3r linear_vel_body = VectorMath::transformToBodyFrame(relative_vel, current.pose.orientation);
                real_T u = linear_vel_body.x();
                real_T v = linear_vel_body.y();
                real_T w = linear_vel_body.z();
                std::vector<real_T> V{ u , v , w };
                real_T Va = sqrt(u * u + v * v + w * w);

                // Obtain the angle of attack
                real_T alpha;
                if (Va >= 0.01)
                {
                    alpha = asin(w / Va) * 57.3;
                }
                else
                {
                    alpha = 0;
                }

                // Normal force from the static wind tunnel test
                static std::vector<real_T> AoA_airframe{ 90, 75, 60, 45, 30, 15, 0, -15, -30, -45, -75, -90 };
                static std::vector<real_T> Cz_airframe{ -0.0115, -0.0124, -0.0137, -0.0128, -0.0100, -0.0063, 0.0014, 0.0045, 0.007, 0.0094, 0.0119, 0.0120 };
                if (AoA_airframe[0] > AoA_airframe[1])
                {
                    std::reverse(AoA_airframe.begin(), AoA_airframe.end());
                    std::reverse(Cz_airframe.begin(), Cz_airframe.end());
                }

                real_T CN_airframe = interp1(AoA_airframe, Cz_airframe, alpha);
                real_T T0 = -CN_airframe * Va * 2;

                // normal force correctness from the flight data
                real_T w_constraint = w;
                if (w_constraint <= -6)
                {
                    w_constraint = -6;
                }
                else if (w_constraint > 2)
                {
                    w_constraint = 2;
                }
                real_T u_constraint = u;
                real_T v_constraint = v;
                real_T uv_scale = 8 / sqrt(u * u + v * v);
                if (uv_scale <= 1)
                {
                    u_constraint = uv_scale * u;
                    v_constraint = uv_scale * v;
                }
                std::vector<real_T> AT0 = P33(std::vector<real_T> {u_constraint}, std::vector<real_T> {abs(v_constraint)}, std::vector<real_T> {w_constraint});
                std::vector<real_T> k_model_1{ -0.0463911782738117, 0.126912947052739, 0.324191845756361, -0.0557628235059462, 0.00571250782560552, -0.103210100621382, -0.0146821184410235, 0.0199520548034235, -0.138168259069616, 0.0273216857565274, -0.00105647803825825, 0.00634522471334950, 0.00166114145301890, -0.00689017065134193, -0.00104094928681998, -0.00176014569852436, 0.00304889473917665, 0.00866535042034273, -0.00554316427701624, -0.0137422347201967 };
                real_T T_corr;
                T_corr = dot_product(AT0, k_model_1);

                // Calculate Ctand Cq of each rotor
                std::vector<int> SL{ 1, -1, -1, 1 };
                std::vector<int> SM{ 1, 1, -1, -1 };
                std::vector<int> SN{ signr * 1, signr * -1, signr * 1, signr * -1 };

                std::vector<real_T> d1{ l, -b, 0 };
                std::vector<real_T> d2{ l, b, 0 };
                std::vector<real_T> d3{ -l, b, 0 };
                std::vector<real_T> d4{ -l, -b, 0 };

                // The speed in u, vand w experienced by each rotor
                std::vector<real_T> pqr{ avg_angular.x(),  avg_angular.y(),  avg_angular.z() };
                std::vector<real_T> V1(3), V2(3), V3(3), V4(3);
                crossProduct(pqr, d1, V1);
                crossProduct(pqr, d2, V2);
                crossProduct(pqr, d3, V3);
                crossProduct(pqr, d4, V4);
                std::transform(V1.begin(), V1.end(), V.begin(), V1.begin(), std::plus<real_T>());
                std::transform(V2.begin(), V2.end(), V.begin(), V2.begin(), std::plus<real_T>());
                std::transform(V3.begin(), V3.end(), V.begin(), V3.begin(), std::plus<real_T>());
                std::transform(V4.begin(), V4.end(), V.begin(), V4.begin(), std::plus<real_T>());

                // The speed in u, vand w experienced by each rotor
                real_T u1 = V1[0]; real_T v1 = V1[1]; real_T w1 = V1[3];
                real_T u2 = V2[0]; real_T v2 = V2[1]; real_T w2 = V2[3];
                real_T u3 = V3[0]; real_T v3 = V3[1]; real_T w3 = V3[3];
                real_T u4 = V4[0]; real_T v4 = V4[1]; real_T w4 = V4[3];

                // Airspeed experienced by each rotor
                real_T va1 = sqrt(u1 * u1 + v1 * v1 + w1 * w1);
                real_T va2 = sqrt(u2 * u2 + v2 * v2 + w2 * w2);
                real_T va3 = sqrt(u3 * u3 + v3 * v3 + w3 * w3);
                real_T va4 = sqrt(u4 * u4 + v4 * v4 + w4 * w4);

                // Computation of the advance ratio
                real_T vv1 = va1 / (omega1 * R);
                if (isnan(vv1) || isinf(vv1)) { vv1 = 0; }
                if (vv1 >= 0.6) { vv1 = 0.6; }

                real_T vv2 = va2 / (omega2 * R);
                if (isnan(vv2) || isinf(vv2)) { vv2 = 0; }
                if (vv2 >= 0.6) { vv2 = 0.6; }

                real_T vv3 = va3 / (omega3 * R);
                if (isnan(vv3) || isinf(vv3)) { vv3 = 0; }
                if (vv3 >= 0.6) { vv3 = 0.6; }

                real_T vv4 = va4 / (omega4 * R);
                if (isnan(vv4) || isinf(vv4)) { vv4 = 0; }
                if (vv4 >= 0.6) { vv4 = 0.6; }

                // Computation of the angle of attack of each propeller
                real_T alpha1 = atan(w1 / sqrt(u1 * u1 + v1 * v1)) * 57.3;
                if (isnan(alpha1) || isinf(abs(alpha1))) { alpha1 = 0; }

                real_T alpha2 = atan(w2 / sqrt(u2 * u2 + v2 * v2)) * 57.3;
                if (isnan(alpha2) || isinf(abs(alpha2))) { alpha2 = 0; }

                real_T alpha3 = atan(w3 / sqrt(u3 * u3 + v3 * v3)) * 57.3;
                if (isnan(alpha3) || isinf(abs(alpha3))) { alpha3 = 0; }

                real_T alpha4 = atan(w4 / sqrt(u4 * u4 + v4 * v4)) * 57.3;
                if (isnan(alpha4) || isinf(abs(alpha4))) { alpha4 = 0; }

                // The density times the square of the radius of the propeller times the
                // square of the rotational speed
                real_T rhoRR = rho * R * R;
                real_T dynhead1 = rhoRR * omega1 * omega1;
                real_T dynhead2 = rhoRR * omega2 * omega2;
                real_T dynhead3 = rhoRR * omega3 * omega3;
                real_T dynhead4 = rhoRR * omega4 * omega4;

                // Ct0 and Cq0 from the static wind tunnel test data
                // Ct is used for the thrust of the rotor.Ct0X is a function of the angle
                // of attack of the bladeand the advance ratio.The relation between these
                // quantities is approximated by a 5th degree order polynomial that use the
                // blade angle of attack and the advance ratio as parameters, multiplied by
                // SI coefficients under the name K_Ct0.The explanation can be found in the
                // paper "Aerodynamic Model Identification of a Quadrotor Subjected to Rotor
                // Failures in the High - Speed Flight Regime", Equation 9.
                std::vector<real_T> k_Ct0{ 0.0152457017219075, -3.19835880466424e-05, -0.0474659629880834, -5.48089604291955e-08, -0.000164550969624146, 0.650877249185920, 1.10477778832442e-08, -9.76752919452344e-06, 0.00859691522825337, -2.20418122442645, 3.27434126987218e-11, -5.69117054658112e-08, 2.32561854294217e-05, -0.0116550184566165, 3.04959484433102, -6.00795185558617e-13, 1.81690349314076e-10, -4.63671043348055e-08, -1.52454780569063e-05, 0.00607313609112646, -1.51563942225535 };

                std::vector<real_T> Ct01_P52 = P52(std::vector<real_T> {alpha1}, std::vector<real_T> {vv1});
                real_T Ct01 = dot_product(Ct01_P52, k_Ct0);

                std::vector<real_T> Ct02_P52 = P52(std::vector<real_T> {alpha2}, std::vector<real_T> {vv2});
                real_T Ct02 = dot_product(Ct02_P52, k_Ct0);

                std::vector<real_T> Ct03_P52 = P52(std::vector<real_T> {alpha3}, std::vector<real_T> {vv3});
                real_T Ct03 = dot_product(Ct03_P52, k_Ct0);

                std::vector<real_T> Ct04_P52 = P52(std::vector<real_T> {alpha4}, std::vector<real_T> {vv4});
                real_T Ct04 = dot_product(Ct04_P52, k_Ct0);

                // Cq is used for the drag torque of the rotor
                std::vector<real_T> k_Cq0{ -0.000166978387654207, -9.26661647846620e-07, -0.000161106517356852, 1.49219451037256e-09, -2.80468068962665e-06, 0.000591396065463947, 4.46363200546300e-10, 8.90349145739088e-08, -1.53880349952214e-05, -0.00773976740405967, -3.70391296926118e-13, 3.92836511888492e-10, -1.33297247718639e-08, -0.000133549679393062, 0.0164947421115812, -4.17586454158575e-14, -3.24864794974322e-12, 1.14205811263298e-09, -6.42233810561959e-08, 0.000149532607712236, -0.0106110955476936 };

                real_T Cq01 = dot_product(Ct01_P52, k_Cq0);
                real_T Cq02 = dot_product(Ct02_P52, k_Cq0);
                real_T Cq03 = dot_product(Ct03_P52, k_Cq0);
                real_T Cq04 = dot_product(Ct04_P52, k_Cq0);

                // Similar to the angle of attack equation-- > horizontal advance ratio.The
                // explanation of this quantity is found in the paper "Aerodynamic Model 
                // Identification of a Quadrotor Subjected to Rotor Failures in the
                // High - Speed Flight Regime", Equation 20.
                real_T mu1 = sqrt(u1 * u1 + v1 * v1) / (omega1 * R);
                if (isnan(mu1) || isinf(abs(mu1))) { mu1 = 0; }
                real_T mu2 = sqrt(u2 * u2 + v2 * v2) / (omega2 * R);
                if (isnan(mu2) || isinf(abs(mu2))) { mu2 = 0; }
                real_T mu3 = sqrt(u3 * u3 + v3 * v3) / (omega3 * R);
                if (isnan(mu3) || isinf(abs(mu3))) { mu3 = 0; }
                real_T mu4 = sqrt(u4 * u4 + v4 * v4) / (omega4 * R);
                if (isnan(mu4) || isinf(abs(mu4))) { mu4 = 0; }

                // Similar to the sideslipe angle equation
                real_T lc1 = w1 / (omega1 * R);
                if (isnan(lc1) || isinf(abs(lc1))) { lc1 = 0; }
                real_T lc2 = w2 / (omega2 * R);
                if (isnan(lc2) || isinf(abs(lc2))) { lc2 = 0; }
                real_T lc3 = w3 / (omega3 * R);
                if (isnan(lc3) || isinf(abs(lc3))) { lc3 = 0; }
                real_T lc4 = w4 / (omega4 * R);
                if (isnan(lc4) || isinf(abs(lc4))) { lc4 = 0; }

                real_T beta = calc_beta2(u, v) * 57.3;
                real_T psi_h1 = beta - 413; psi_h1 = psi_h1 / 57.3;
                real_T psi_h2 = beta - 307; psi_h2 = psi_h2 / 57.3;
                real_T psi_h3 = beta - 233; psi_h3 = psi_h3 / 57.3;
                real_T psi_h4 = beta - 127; psi_h4 = psi_h4 / 57.3;

                psi_h1 = fmod(psi_h1, 2 * M_PIf);
                psi_h2 = fmod(psi_h2, 2 * M_PIf);
                psi_h3 = fmod(psi_h3, 2 * M_PIf);
                psi_h4 = fmod(psi_h4, 2 * M_PIf);

                // calculate dCt and dCq using model identified from the flight data
                std::vector<real_T> k_model_2{ 0.00274750362242118, 0.0587325418628517, 0.0291979006795257, 0.155176381977433, -0.848919654295447, -2.85285652127970, -16.6872606424138, -25.3582092758054, -8.21139486023900, 0.000662666074942486, -0.0137515544490184, 0.0258468383560923, 0.129354278831284, 0.739022953068088, -0.751589665006720, 2.30225029828906, 3.19387485842342, -2.01400124775404, -0.0327090226346993, 0.00550048663001955, 0.704747484311295, 0.384042859177342, 0.409107040799852, -2.91693142809590, -5.72731924259749, -3.84424311448819, 0.957068915766478, 0.00798767042006989, -0.0658174319226979, -0.515362725845307, 0.154017181898898, 1.07229345471127, 5.60834749404815, 3.12341580631406, 13.2751387862931, 3.38340384818304, -0.00871325200163225, 0.0139319909808224, 0.135829051260073, 0.0724018634704221, 0.462231305873754, 1.07728548843851, -2.92439099099261, 2.07387265629944, -1.76236683822441, 0.00277901355913424, 5.93712461960435e-05, -0.0737682036851551, 0.408392701436168, 0.181780336855863, -0.0914796558508702, -5.33048488631146, -11.6294693255163, -4.72950404100762, -0.00594871416216384, -0.0162850806730608, 0.173368295316786, 0.186292675296392, 0.225644067201894, -0.688845939593434, -6.49432628543192, -7.80900137821226, 0.415239218701371, -0.00544216811616573, 0.00518487316578840, 0.0476580090813803, -0.200801241660794, -0.476117215479456, -0.407991135460875, -1.81735072025647, 1.50472930028764, 4.35662490484023, -0.00159368739623987, 0.000467723919419556, 0.0129022985413385, -0.142747208717601, -0.286423056758624, -0.233246678589007, 5.27930446169201, 6.06363387971617, 3.14128857337644, 0.00453268191002699, -0.00474962613583822, -0.180460224377998, -0.0116017180130748, 0.0192198318847662, 1.17708508701190, 0.0640467785184096, 3.10723451211166, 0.482465692101886 };
                std::vector<real_T> k_model_11{ 0.00260329204354066, 0.00129328992586148, -0.0199809965492002, -0.0868022523710462, -0.0889469386700429, 0.128032771798353, 0.146886709138850, 0.524080931866815, 0.725843471299357, 0.00242937984350116, -0.00310550867822261, -0.0595768021706452, 0.0523222113704624, 0.0799385477524136, 0.0802433226135493, 0.387865290852874, 0.137337555435232, -0.310321282567866, 0.00158155254379188, 0.00319704874615568, -0.0554013498676434, -0.133883081875846, -0.154861909695999, 0.246917675390354, 0.0807388330437734, 1.21408540541708, 0.991981880292023, -9.00820660019962e-05, 0.000417739287775632, -0.00176625889617756, -0.0352354581017755, 0.00347023118130632, -0.0818779712415576, -0.0939352353976481, 0.367104057232038, -0.239846676494934, 0.000548702590051651, 0.000217200486637933, -0.00564899836836745, -0.000264397140190192, 0.00896129402789547, -0.0942019724552947, 0.0408551476683280, 0.607021266741172, 0.0144874105803823, 0.000847230370183477, -0.000948252583147180, -0.00265605533100469, 0.0598956109168678, 0.0807953120897514, -0.0545778293654141, -0.235368707057857, -0.948022031763549, -0.608815444932934, -0.000182959785330574, 0.00167139842657429, 0.00833552390363391, 0.0167067780351973, -0.00216159653990414, -0.0668352653475071, 0.0332682896037231, -0.220002714254035, -0.100740744918869, -0.000459348737065979, -0.00323901937377689, 0.0150989940672047, -0.00337931488830346, 0.0705271437626767, -0.0355357034004435, -0.0945407727921580, -0.114237238851565, -0.348109605269992, -0.000423056934179010, -1.57962640331396e-05, 0.00625198744041810, -0.0204741957877981, -0.00655890452523322, -0.0335286749006157, 0.0745650825531103, 0.0289036906676707, -0.0296758936977819, -0.000231091410645385, -0.000748657303930713, 0.00208598921233990, -0.0132023573075178, 0.0116429676033409, 0.0151697188209396, -0.0404565223580964, 0.178329482629743, 0.0297489549373982 };
                std::vector<real_T> Fn1 = Fn(std::vector<real_T> {psi_h1}, h, 0, std::vector<real_T> {1}, std::vector<real_T> {mu1}, std::vector<real_T> {lc1});
                real_T dCt_1;
                dCt_1 = dot_product(Fn1, k_model_2);

                std::vector<real_T> Fn2 = Fn(std::vector<real_T> {2 * M_PIf - psi_h2}, h, 0, std::vector<real_T> {1}, std::vector<real_T> {mu2}, std::vector<real_T> {lc2});
                real_T dCt_2;
                dCt_2 = dot_product(Fn2, k_model_2);

                std::vector<real_T> Fn3 = Fn(std::vector<real_T> {psi_h3}, h, 0, std::vector<real_T> {1}, std::vector<real_T> {mu3}, std::vector<real_T> {lc3});
                real_T dCt_3;
                dCt_3 = dot_product(Fn3, k_model_2);

                std::vector<real_T> Fn4 = Fn(std::vector<real_T> {2 * M_PIf - psi_h4}, h, 0, std::vector<real_T> {1}, std::vector<real_T> {mu4}, std::vector<real_T> {lc4});
                real_T dCt_4;
                dCt_4 = dot_product(Fn4, k_model_2);

                real_T dCq_1;
                dCq_1 = dot_product(Fn1, k_model_11);

                real_T dCq_2;
                dCq_2 = dot_product(Fn2, k_model_11);

                real_T dCq_3;
                dCq_3 = dot_product(Fn3, k_model_11);

                real_T dCq_4;
                dCq_4 = dot_product(Fn4, k_model_11);

                // saturate dCtand dCq for extrapolation
                if (dCt_1 > 0.007) { dCt_1 = 0.007; }
                else if (dCt_1 < -0.007) { dCt_1 = -0.007; }
                if (dCt_2 > 0.007) { dCt_2 = 0.007; }
                else if (dCt_2 < -0.007) { dCt_2 = -0.007; }
                if (dCt_3 > 0.007) { dCt_3 = 0.007; }
                else if (dCt_3 < -0.007) { dCt_3 = -0.007; }
                if (dCt_4 > 0.007) { dCt_4 = 0.007; }
                else if (dCt_4 < -0.007) { dCt_4 = -0.007; }

                if (dCq_1 > 0.0001) { dCq_1 = 0.0001; }
                else if (dCq_1 < -0.0007) { dCq_1 = -0.0007; }
                if (dCq_2 > 0.0001) { dCq_2 = 0.0001; }
                else if (dCq_2 < -0.0007) { dCq_2 = -0.0007; }
                if (dCq_3 > 0.0001) { dCq_3 = 0.0001; }
                else if (dCq_3 < -0.0007) { dCq_3 = -0.0007; }
                if (dCq_4 > 0.0001) { dCq_4 = 0.0001; }
                else if (dCq_4 < -0.0007) { dCq_4 = -0.0007; }

                // interaction effect is negligible when V < 2m / s;
                real_T vh = sqrt(u * u + v * v);
                dCt_1 = 1 / (1 + exp(-6 * (vh - 1))) * dCt_1;
                dCt_2 = 1 / (1 + exp(-6 * (vh - 1))) * dCt_2;
                dCt_3 = 1 / (1 + exp(-6 * (vh - 1))) * dCt_3;
                dCt_4 = 1 / (1 + exp(-6 * (vh - 1))) * dCt_4;

                dCq_1 = 1 / (1 + exp(-6 * (vh - 1))) * dCq_1;
                dCq_2 = 1 / (1 + exp(-6 * (vh - 1))) * dCq_2;
                dCq_3 = 1 / (1 + exp(-6 * (vh - 1))) * dCq_3;
                dCq_4 = 1 / (1 + exp(-6 * (vh - 1))) * dCq_4;

                // Forces and moments of each rotor
                // The following equations compute the thrust of each motor.The equations
                // are obtained from the paper "Multirotor Aerial Vehicles: Modeling,
                // Estimation and Control of Quadrotor", Equation 2. This equation can also
                // be found in the book of "Basic Helicopter Aerodynamics", between
                // Equations 2.4 and 2.5
                real_T T1 = (Ct01 + dCt_1) * dynhead1 * Area;
                real_T T2 = (Ct02 + dCt_2) * dynhead2 * Area;
                real_T T3 = (Ct03 + dCt_3) * dynhead3 * Area;
                real_T T4 = (Ct04 + dCt_4) * dynhead4 * Area;

                // Computation of the forces in the x - direction.It is explained in Equation
                // 23 of the paper "Aerodynamic Model Identification of a Quadrotor 
                // Subjected to Rotor Failures in the High - Speed Flight Regime"
                real_T k_model_3 = -4.18219980688138e-05;
                real_T k_model_4 = 2.75369651421482e-05;
                real_T X1 = u1 * omega1 * k_model_3 + SN[0] * v1 * omega1 * k_model_4;
                real_T X2 = u2 * omega2 * k_model_3 + SN[1] * v2 * omega2 * k_model_4;
                real_T X3 = u3 * omega3 * k_model_3 + SN[2] * v3 * omega3 * k_model_4;
                real_T X4 = u4 * omega4 * k_model_3 + SN[3] * v4 * omega4 * k_model_4;

                // Computation of the forces in the y - direction.It is explained in Equation
                // 23 of the paper "Aerodynamic Model Identification of a Quadrotor 
                // Subjected to Rotor Failures in the High - Speed Flight Regime"
                real_T k_model_5 = -5.43414653058895e-05;
                real_T k_model_6 = -1.34375303328745e-05;
                real_T Y1 = SN[0] * u1 * omega1 * k_model_6 + v1 * omega1 * k_model_5;
                real_T Y2 = SN[1] * u2 * omega2 * k_model_6 + v2 * omega2 * k_model_5;
                real_T Y3 = SN[2] * u3 * omega3 * k_model_6 + v3 * omega3 * k_model_5;
                real_T Y4 = SN[3] * u4 * omega4 * k_model_6 + v4 * omega4 * k_model_5;

                // Computation of moments around the x axis.It is explained in Equation
                // 24 of the paper "Aerodynamic Model Identification of a Quadrotor 
                // Subjected to Rotor Failures in the High - Speed Flight Regime"
                real_T k_model_7 = -6.49293933727443e-06;
                real_T k_model_8 = 1.99308688196749e-06;
                real_T L1 = SN[0] * u1 * omega1 * k_model_8 + v1 * omega1 * k_model_7;
                real_T L2 = SN[1] * u2 * omega2 * k_model_8 + v2 * omega2 * k_model_7;
                real_T L3 = SN[2] * u3 * omega3 * k_model_8 + v3 * omega3 * k_model_7;
                real_T L4 = SN[3] * u4 * omega4 * k_model_8 + v4 * omega4 * k_model_7;

                // Computation of moments around the y axis.It is explained in Equation
                // 24 of the paper "Aerodynamic Model Identification of a Quadrotor 
                // Subjected to Rotor Failures in the High - Speed Flight Regime"
                real_T k_model_9 = 3.95678611524143e-06;
                real_T k_model_10 = 2.78425962530407e-07;
                real_T M1 = u1 * omega1 * k_model_9 + SN[0] * v1 * omega1 * k_model_10;
                real_T M2 = u2 * omega2 * k_model_9 + SN[1] * v2 * omega2 * k_model_10;
                real_T M3 = u3 * omega3 * k_model_9 + SN[2] * v3 * omega3 * k_model_10;
                real_T M4 = u4 * omega4 * k_model_9 + SN[3] * v4 * omega4 * k_model_10;

                // Computation of moments around the z axis.When applied to the propellers,
                // it would be the drag torque.I think it is missing a factor of the
                // propeller radius, as can be seen from equation 7 in the paper
                // "Aerodynamic Model Identification of a Quadrotor Subjected to Rotor
                // Failures in the High - Speed Flight Regime"
                real_T N1 = SN[0] * (Cq01 + dCq_1) * dynhead1 * Area;
                real_T N2 = SN[1] * (Cq02 + dCq_2) * dynhead2 * Area;
                real_T N3 = SN[2] * (Cq03 + dCq_3) * dynhead3 * Area;
                real_T N4 = SN[3] * (Cq04 + dCq_4) * dynhead4 * Area;

                real_T T = T0 + T1 + T2 + T3 + T4 + T_corr;
                real_T Fx = X1 + X2 + X3 + X4;
                real_T Fy = Y1 + Y2 + Y3 + Y4;

                // When computing the moments, first the forces are taken into
                // consideration, followed by all the moments or torques.In the case of
                // moments in the z - direction, the xand y forces both have an effect.band
                // l are the distances in the yand x direction respectively to the center
                // of gravity from each propeller.
                real_T Mx = SL[0] * b * T1 + SL[1] * b * T2 + SL[2] * b * T3 + SL[3] * b * T4 + L1 + L2 + L3 + L4;
                real_T My = SM[0] * l * T1 + SM[1] * l * T2 + SM[2] * l * T3 + SM[3] * l * T4 + M1 + M2 + M3 + M4;
                real_T Mz = b * SL[0] * X1 + b * SL[1] * X2 + b * SL[2] * X3 + b * SL[3] * X4 + l * SM[0] * Y1 + l * SM[1] * Y2 + l * SM[2] * Y3 + l * SM[3] * Y4 + N1 + N2 + N3 + N4;

                // Obtain the force and moment vector
                Wrench wrench = Wrench::zero();
                Vector3r local_force = Vector3r(Fx, Fy, -T);
                Vector3r local_torque = Vector3r(Mx, My, Mz);
                wrench.force = local_force;
                wrench.torque = local_torque;

                //convert force to world frame, leave torque to local frame
                wrench.force = VectorMath::transformToWorldFrame(wrench.force, current.pose.orientation);

                if (body.isGrounded()) {
                    // make it stick to the ground until the magnitude of net external force on body exceeds its weight.
                    float external_force_magnitude = wrench.force.squaredNorm();
                    Vector3r weight = body.getMass() * body.getEnvironment().getState().gravity;
                    float weight_magnitude = weight.squaredNorm();
                    if (external_force_magnitude >= weight_magnitude)
                    {
                        body.setGrounded(false);
                    }
                    next_wrench.force = Vector3r::Zero();
                    next_wrench.torque = Vector3r::Zero();
                    next.accelerations.linear = Vector3r::Zero();
                }
                else {
                    next_wrench = wrench;

                    /************************* Update accelerations due to force and torque ************************/
                    //get new acceleration due to force - we'll use this acceleration in next time step
                    // Transform to the body frame the linear velocity of the body
                    const Vector3r Vb = VectorMath::transformToBodyFrame(avg_linear, current.pose.orientation);

                    // Compute the cross product of the angular velocities and the body linear velocities in the body frame.
                    Vector3r Vb_pqr_cross = avg_angular.cross(Vb);

                    // Convert back to WorldFrame format
                    Vb_pqr_cross = VectorMath::transformToWorldFrame(Vb_pqr_cross, current.pose.orientation);

                    // Compute the next linear accelerations
                    next.accelerations.linear = (next_wrench.force / body.getMass()) + body.getEnvironment().getState().gravity - Vb_pqr_cross;

                }

                if (body.isGrounded()) {
                    // this stops vehicle from vibrating while it is on the ground doing nothing.
                    next.accelerations.angular = Vector3r::Zero();
                    next.twist.linear = Vector3r::Zero();
                    next.twist.angular = Vector3r::Zero();
                }
                else {
                    //get new angular acceleration
                    //Euler's rotation equation: https://en.wikipedia.org/wiki/Euler's_equations_(body_dynamics)
                    //we will use torque to find out the angular acceleration
                    //angular momentum L = I * omega
                    const Vector3r angular_momentum = body.getInertia() * avg_angular;

                    // The gyroscopic moment has to be computed
                    // First the propeller Moment of Inertia is established
                    Matrix3x3r Ip = Matrix3x3r::Zero();
                    Ip(0, 0) = 4.2e-06; Ip(0, 1) = 0; Ip(0, 2) = 0;
                    Ip(1, 0) = 0; Ip(1, 1) = 4.2e-06; Ip(1, 2) = 0;
                    Ip(2, 0) = 0; Ip(2, 1) = 0; Ip(2, 2) = 8.0e-06;

                    // Then the gryoscopic part of the moment
                    const Vector3r w1_vector = Vector3r(0, 0, omega1);
                    const Vector3r w2_vector = Vector3r(0, 0, -omega2);
                    const Vector3r w3_vector = Vector3r(0, 0, omega3);
                    const Vector3r w4_vector = Vector3r(0, 0, -omega4);
                    const Vector3r M_gyro_second = avg_angular.cross(Ip * w1_vector + Ip * w2_vector + Ip * w3_vector + Ip * w4_vector);

                    real_T omega1_dot = (omega1 - omega1_last) / dt_real;
                    real_T omega2_dot = (omega2 - omega2_last) / dt_real;
                    real_T omega3_dot = (omega3 - omega3_last) / dt_real;
                    real_T omega4_dot = (omega4 - omega4_last) / dt_real;
                    const Vector3r w1_dot_vector = Vector3r(0, 0, omega1_dot);
                    const Vector3r w2_dot_vector = Vector3r(0, 0, -omega2_dot);
                    const Vector3r w3_dot_vector = Vector3r(0, 0, omega3_dot);
                    const Vector3r w4_dot_vector = Vector3r(0, 0, -omega4_dot);
                    const Vector3r M_gyro_first = signr * (Ip * w1_dot_vector + Ip * w2_dot_vector + Ip * w3_dot_vector + Ip * w4_dot_vector);

                    omega1_last = omega1;
                    omega2_last = omega2;
                    omega3_last = omega3;
                    omega4_last = omega4;


                    const Vector3r M_gyro = M_gyro_first + M_gyro_second;
                    const Vector3r angular_momentum_rate = next_wrench.torque - M_gyro - avg_angular.cross(angular_momentum);
                    //new angular acceleration - we'll use this acceleration in next time step
                    next.accelerations.angular = body.getInertiaInv() * angular_momentum_rate;

                    /************************* Update pose and twist after dt ************************/
                    //Verlet integration: http://www.physics.udel.edu/~bnikolic/teaching/phys660/numerical_ode/node5.html
                    next.twist.linear = current.twist.linear + (current.accelerations.linear + next.accelerations.linear) * (0.5f * dt_real);
                    next.twist.angular = current.twist.angular + (current.accelerations.angular + next.accelerations.angular) * (0.5f * dt_real);

                    //if controller has bug, velocities can increase idenfinitely 
                    //so we need to clip this or everything will turn in to infinity/nans

                    if (next.twist.linear.squaredNorm() > EarthUtils::SpeedOfLight * EarthUtils::SpeedOfLight) { //speed of light
                        next.twist.linear /= (next.twist.linear.norm() / EarthUtils::SpeedOfLight);
                        next.accelerations.linear = Vector3r::Zero();
                    }
                    //
                    //for disc of 1m radius which angular velocity translates to speed of light on tangent?
                    if (next.twist.angular.squaredNorm() > EarthUtils::SpeedOfLight * EarthUtils::SpeedOfLight) { //speed of light
                        next.twist.angular /= (next.twist.angular.norm() / EarthUtils::SpeedOfLight);
                        next.accelerations.angular = Vector3r::Zero();
                    }
                }
                real_T x_location = current.pose.position.x();
                computeNextPose(dt, current.pose, avg_linear, avg_angular, next);
            }
            static void getNextKinematicsNoCollision(TTimeDelta dt, PhysicsBody& body, const Kinematics::State& current,
                Kinematics::State& next, Wrench& next_wrench, const Vector3r& wind, float prop_damage[])
            {
                const real_T dt_real = static_cast<real_T>(dt);

                Vector3r avg_linear = Vector3r::Zero();
                Vector3r avg_angular = Vector3r::Zero();

                /************************* Get force and torque acting on body ************************/
                //set wrench sum to zero
                const Wrench body_wrench = getBodyWrench(body, current.pose.orientation, prop_damage);

                if (body.isGrounded()) {
                    // make it stick to the ground until the magnitude of net external force on body exceeds its weight.
                    float external_force_magnitude = body_wrench.force.squaredNorm();
                    Vector3r weight = body.getMass() * body.getEnvironment().getState().gravity;
                    float weight_magnitude = weight.squaredNorm();
                    if (external_force_magnitude >= weight_magnitude)
                    {
                        //throttledLogOutput("*** Losing ground lock due to body_wrench " + VectorMath::toString(body_wrench.force), 0.1);
                        body.setGrounded(false);
                    }
                    next_wrench.force = Vector3r::Zero();
                    next_wrench.torque = Vector3r::Zero();
                    next.accelerations.linear = Vector3r::Zero();
                }
                else {
                    //add linear drag due to velocity we had since last dt seconds + wind
                    //drag vector magnitude is proportional to v^2, direction opposite of velocity
                    //total drag is b*v + c*v*v but we ignore the first term as b << c (pg 44, Classical Mechanics, John Taylor)
                    //To find the drag force, we find the magnitude in the body frame and unit vector direction in world frame
                    avg_linear = current.twist.linear + current.accelerations.linear * (0.5f * dt_real);
                    avg_angular = current.twist.angular + current.accelerations.angular * (0.5f * dt_real);
                    const Wrench drag_wrench = getDragWrench(body, current.pose.orientation, avg_linear, avg_angular, wind);

                    next_wrench = body_wrench + drag_wrench;

                    //Utils::log(Utils::stringf("B-WRN %s: ", VectorMath::toString(body_wrench.force).c_str()));
                    //Utils::log(Utils::stringf("D-WRN %s: ", VectorMath::toString(drag_wrench.force).c_str()));

                    /************************* Update accelerations due to force and torque ************************/
                    //get new acceleration due to force - we'll use this acceleration in next time step

                    next.accelerations.linear = (next_wrench.force / body.getMass()) + body.getEnvironment().getState().gravity;
                }


                if (body.isGrounded()) {
                    // this stops vehicle from vibrating while it is on the ground doing nothing.
                    next.accelerations.angular = Vector3r::Zero();
                    next.twist.linear = Vector3r::Zero();
                    next.twist.angular = Vector3r::Zero();
                }
                else {
                    //get new angular acceleration
                    //Euler's rotation equation: https://en.wikipedia.org/wiki/Euler's_equations_(body_dynamics)
                    //we will use torque to find out the angular acceleration
                    //angular momentum L = I * omega
                    const Vector3r angular_momentum = body.getInertia() * avg_angular;
                    const Vector3r angular_momentum_rate = next_wrench.torque - avg_angular.cross(angular_momentum);
                    //new angular acceleration - we'll use this acceleration in next time step
                    next.accelerations.angular = body.getInertiaInv() * angular_momentum_rate;

                    /************************* Update pose and twist after dt ************************/
                    //Verlet integration: http://www.physics.udel.edu/~bnikolic/teaching/phys660/numerical_ode/node5.html
                    next.twist.linear = current.twist.linear + (current.accelerations.linear + next.accelerations.linear) * (0.5f * dt_real);
                    next.twist.angular = current.twist.angular + (current.accelerations.angular + next.accelerations.angular) * (0.5f * dt_real);

                    //if controller has bug, velocities can increase idenfinitely 
                    //so we need to clip this or everything will turn in to infinity/nans

                    if (next.twist.linear.squaredNorm() > EarthUtils::SpeedOfLight * EarthUtils::SpeedOfLight) { //speed of light
                        next.twist.linear /= (next.twist.linear.norm() / EarthUtils::SpeedOfLight);
                        next.accelerations.linear = Vector3r::Zero();
                    }
                    //
                    //for disc of 1m radius which angular velocity translates to speed of light on tangent?
                    if (next.twist.angular.squaredNorm() > EarthUtils::SpeedOfLight * EarthUtils::SpeedOfLight) { //speed of light
                        next.twist.angular /= (next.twist.angular.norm() / EarthUtils::SpeedOfLight);
                        next.accelerations.angular = Vector3r::Zero();
                    }
                }

                computeNextPose(dt, current.pose, avg_linear, avg_angular, next);

                //Utils::log(Utils::stringf("N-VEL %s %f: ", VectorMath::toString(next.twist.linear).c_str(), dt));
                //Utils::log(Utils::stringf("N-POS %s %f: ", VectorMath::toString(next.pose.position).c_str(), dt));

            }

            static void computeNextPose(TTimeDelta dt, const Pose& current_pose, const Vector3r& avg_linear, const Vector3r& avg_angular, Kinematics::State& next)
            {
                real_T dt_real = static_cast<real_T>(dt);

                next.pose.position = current_pose.position + avg_linear * dt_real;

                //use angular velocty in body frame to calculate angular displacement in last dt seconds
                real_T angle_per_unit = avg_angular.norm();
                if (Utils::isDefinitelyGreaterThan(angle_per_unit, 0.0f)) {
                    //convert change in angle to unit quaternion
                    AngleAxisr angle_dt_aa = AngleAxisr(angle_per_unit * dt_real, avg_angular / angle_per_unit);
                    Quaternionr angle_dt_q = Quaternionr(angle_dt_aa);
                    /*
                    Add change in angle to previous orientation.
                    Proof that this is q0 * q1:
                    If rotated vector is qx*v*qx' then qx is attitude
                    Initially we have q0*v*q0'
                    Lets transform this to body coordinates to get
                    q0'*(q0*v*q0')*q0
                    Then apply q1 rotation on it to get
                    q1(q0'*(q0*v*q0')*q0)q1'
                    Then transform back to world coordinate
                    q0(q1(q0'*(q0*v*q0')*q0)q1')q0'
                    which simplifies to
                    q0(q1(v)q1')q0'
                    Thus new attitude is q0q1
                    */
                    next.pose.orientation = current_pose.orientation * angle_dt_q;
                    if (VectorMath::hasNan(next.pose.orientation)) {
                        //Utils::DebugBreak();
                        Utils::log("orientation had NaN!", Utils::kLogLevelError);
                    }

                    //re-normalize quaternion to avoid accumulating error
                    next.pose.orientation.normalize();
                }
                else //no change in angle, because angular velocity is zero (normalized vector is undefined)
                    next.pose.orientation = current_pose.orientation;
            }

        private:
            static constexpr uint kCollisionResponseCycles = 1;
            static constexpr float kAxisTolerance = 0.25f;
            static constexpr float kRestingVelocityMax = 0.1f;
            static constexpr float kDragMinVelocity = 0.1f;

            std::stringstream debug_string_;
            bool enable_ground_lock_;
            TTimePoint last_message_time;
            Vector3r wind_;
            float propeller_damage_coefficients[4] = { 1.0, 1.0, 1.0, 1.0 };

            // Parameter for the Bebop2
            static constexpr int max_w = 1200; // maximum number of radians per second of the propeller
            static constexpr int max_w_squared = max_w * max_w; // maximum number of radians per second of the propeller squared
            static constexpr real_T R = 0.075; // radius described by the propeller
            static constexpr real_T l = 0.0875; // distance of propeller to the y-axis of the drone
            static constexpr real_T b = 0.1150; // distance of propeller to x-axis
            static constexpr int signr = -1;
            static constexpr real_T rho = 1.225;  // density at the altitude in which the drone flies
            static constexpr int h = 5;   // variable used in the computation of dCt and dCq

            real_T omega1_last = 0;
            real_T omega2_last = 0;
            real_T omega3_last = 0;
            real_T omega4_last = 0;

            FirstOrderFilter<real_T> control_signal_filter_w1;
            FirstOrderFilter<real_T> control_signal_filter_w2;
            FirstOrderFilter<real_T> control_signal_filter_w3;
            FirstOrderFilter<real_T> control_signal_filter_w4;
        };

    }
} //namespace
#endif
